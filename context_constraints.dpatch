Mon Mar  8 15:30:17 PST 2010  matt@softmechanics.net
  * Context Constraints

Sun Mar 14 22:41:58 PDT 2010  matt@softmechanics.net
  * Context Constraints Part 2
  
  Can now correct deduce which instance to use from type variables, in 
  addition to (concrete) types.  lookupPred is still the main driver, 
  and there is still lots of debug code in there, from trying to find the
  best method.  
  
  Two big changes to the simplification loop:  the first is that a function
  that checks if a matching Inst is available (Inst -> TcM Bool) is passed
  down to lookupPred.  This could be remedied by importing findAvail into 
  Inst.lhs.
  
  The second was a simple solution to the problem of deciding an instance
  for type variables too early.  That is, before all the other instances for
  the typeclass parameters have been discovered.  The result of choosing too
  early is that a more general instance is chosen than should be.  I addressed
  the problem by modifing passing a boolean "force" argument to lookupPred, indicating
  that it must choose the best matching instance it can now.  If force is False,
  lookupPred will return an instance only if it is the best possible (i.e. no more specific
  instance exists). 
  
  
  

Tue Mar 16 11:05:20 PDT 2010  matt@softmechanics.net
  * Partial Cleanup

Fri Mar 19 10:27:45 PDT 2010  matt@softmechanics.net
  * Improved force logic in lookupPred

Fri Mar 19 14:45:27 PDT 2010  matt@softmechanics.net
  * Use mutual recursion between applyContextConstraints, lookupPred to lookup context predicates

Sun Mar 21 11:24:44 PDT 2010  matt@softmechanics.net
  * New ContextConstraints extension flag
  
  Removed short-circuit logic to always accept a single matched element as properly constrained without checking.  
  Finally added ContextConstraints extension flag.  
  Added param to propagate force flag throughout applyContextConstraints/lookupPred loop.
  Made ContextConstraints always ignore unified instances.
  

Tue Mar 23 22:29:04 PDT 2010  matt@softmechanics.net
  * Context Constraints: Loop Detection
  Added some simple loop detection to the context constraints logic.  

Tue Apr  6 13:25:30 PDT 2010  matt@softmechanics.net
  * Context Constraints

Wed Apr  7 11:59:59 PDT 2010  matt@softmechanics.net
  * Better Handling of Functional Dependencies in Contexts
  1) Need to only allow a predicate to "resolve" a type variable (replace it with
     a concrete type) if the pred has a functional dependency, and no dependencies
     are type variables.  Still todo, in the meantime, make sure we have at least
     one real type (no check for fun dep).  I.e. don't resolve any variable if we
     don't know any types.
  2) If applyContextConstraints resolves any variables, update the type/variable
     parameters for the instance use under consideration.
  

New patches:

[Context Constraints
matt@softmechanics.net**20100308233017
 Ignore-this: 6ffaf8308504978eda2a0c72af9ed137
] {
hunk ./compiler/typecheck/Inst.lhs 753
 		Just specs -> funDepErr ispec' specs
 		Nothing    -> return ()
 
-		-- Check for duplicate instance decls
-	; let { (matches, _) = lookupInstEnv inst_envs cls tys'
-	      ;	dup_ispecs = [ dup_ispec 
-			     | (dup_ispec, _) <- matches
-			     , let (_,_,_,dup_tys) = instanceHead dup_ispec
-			     , isJust (tcMatchTys (mkVarSet tvs') tys' dup_tys)] }
-		-- Find memebers of the match list which ispec itself matches.
-		-- If the match is 2-way, it's a duplicate
-	; case dup_ispecs of
-	    dup_ispec : _ -> dupInstErr ispec' dup_ispec
-	    []            -> return ()
-
 		-- OK, now extend the envt
 	; return (extendInstEnv home_ie ispec') }
 
hunk ./compiler/types/InstEnv.lhs 36
 import UniqFM
 import Id
 import FastString
+import Type (substPred)
 
 import Data.Maybe	( isJust, isNothing )
 \end{code}
hunk ./compiler/types/InstEnv.lhs 450
     (pkg_matches,  pkg_unifs)  = lookup pkg_ie  
     all_matches = home_matches ++ pkg_matches
     all_unifs   = home_unifs   ++ pkg_unifs
-    pruned_matches = foldr insert_overlapping [] all_matches
+    pruned_matches = applyContextConstraints $ foldr insert_overlapping [] all_matches
 	-- Even if the unifs is non-empty (an error situation)
 	-- we still prune the matches, so that the error message isn't
 	-- misleading (complaining of multiple matches when some should be
hunk ./compiler/types/InstEnv.lhs 456
 	-- overlapped away)
 
+    --------------
+    applyContextConstraints x@(_:_:_) = reduceContextMatches $ filter matchesContext x
+    applyContextConstraints x = x
+
+    reduceContextMatches [] = []
+    reduceContextMatches [x] = [x]
+    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
+
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    thetaProperSubset :: ThetaType -> ThetaType -> Bool
+    thetaProperSubset sub super =
+      all inSuper sub
+      where inSuper c = inP c super
+            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+            cmpPred _ _ = False -- TODO: handle other predicates
+
+            inP _ [] = False
+            inP a (b:_) | a `cmpPred` b = True
+            inP a as = inP a $ tail as
+
+    isMostSpecificContext x xs =
+      all (not . thetaProperSubset (theta x)) $ map theta xs
+      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
+
+    matchesContext (match_inst, _) = 
+      all matchesPred theta
+      where (_, theta, _, _) = instanceHead match_inst
+            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
+            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+
+            matchesPred pred@(ClassP _ _) = 
+              case lookupInstEnv (pkg_ie, home_ie) predC predTys of
+                   ([_],_) -> True
+                   (_,_) -> False
+              where (ClassP predC predTys) = substPred subst pred
+            matchesPred _ = False
+
     --------------
     lookup env = case lookupUFM env cls of
 		   Nothing -> ([],[])	-- No instances for this class
}
[Context Constraints Part 2
matt@softmechanics.net**20100315054158
 Ignore-this: 3cff74290775029a8f62469f7de4598f
 
 Can now correct deduce which instance to use from type variables, in 
 addition to (concrete) types.  lookupPred is still the main driver, 
 and there is still lots of debug code in there, from trying to find the
 best method.  
 
 Two big changes to the simplification loop:  the first is that a function
 that checks if a matching Inst is available (Inst -> TcM Bool) is passed
 down to lookupPred.  This could be remedied by importing findAvail into 
 Inst.lhs.
 
 The second was a simple solution to the problem of deciding an instance
 for type variables too early.  That is, before all the other instances for
 the typeclass parameters have been discovered.  The result of choosing too
 early is that a more general instance is chosen than should be.  I addressed
 the problem by modifing passing a boolean "force" argument to lookupPred, indicating
 that it must choose the best matching instance it can now.  If force is False,
 lookupPred will return an instance only if it is the best possible (i.e. no more specific
 instance exists). 
 
 
 
] {
hunk ./compiler/typecheck/Inst.lhs 804
   = NoInstance
   | GenInst [Inst] (LHsExpr TcId)	-- The expression and its needed insts
 
-lookupSimpleInst :: Inst -> TcM LookupInstResult
+lookupSimpleInst :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM LookupInstResult
 -- This is "simple" in that it returns NoInstance for implication constraints
 
 -- It's important that lookupInst does not put any new stuff into
hunk ./compiler/typecheck/Inst.lhs 811
 -- the LIE.  Instead, any Insts needed by the lookup are returned in
 -- the LookupInstResult, where they can be further processed by tcSimplify
 
-lookupSimpleInst (EqInst {}) = return NoInstance
+lookupSimpleInst _ _ (EqInst {}) = return NoInstance
 
 --------------------- Implications ------------------------
hunk ./compiler/typecheck/Inst.lhs 814
-lookupSimpleInst (ImplicInst {}) = return NoInstance
+lookupSimpleInst _ _ (ImplicInst {}) = return NoInstance
 
 --------------------- Methods ------------------------
hunk ./compiler/typecheck/Inst.lhs 817
-lookupSimpleInst (Method {tci_oid = id, tci_tys = tys, tci_theta = theta, tci_loc = loc})
+lookupSimpleInst _ _ (Method {tci_oid = id, tci_tys = tys, tci_theta = theta, tci_loc = loc})
   = do	{ (dict_app, dicts) <- getLIE $ instCallDicts loc theta
 	; let co_fn = dict_app <.> mkWpTyApps tys
 	; return (GenInst dicts (L span $ HsWrap co_fn (HsVar id))) }
hunk ./compiler/typecheck/Inst.lhs 831
 -- [Same shortcut as in newOverloadedLit, but we
 --  may have done some unification by now] 		
 
-lookupSimpleInst (LitInst { tci_lit = lit@OverLit { ol_val = lit_val
+lookupSimpleInst _ _ (LitInst { tci_lit = lit@OverLit { ol_val = lit_val
 					          , ol_rebindable = rebindable }
 			  , tci_ty = ty, tci_loc = iloc})
   | debugIsOn && rebindable = panic "lookupSimpleInst" -- A LitInst invariant
hunk ./compiler/typecheck/Inst.lhs 852
     loc = instLocSpan iloc
 
 --------------------- Dictionaries ------------------------
-lookupSimpleInst (Dict {tci_pred = pred, tci_loc = loc})
-  = do 	{ mb_result <- lookupPred pred
+lookupSimpleInst force availP dct@(Dict {tci_pred = pred, tci_loc = loc})
+  = do 	{ mb_result <- lookupPred force availP dct
 	; case mb_result of {
 	    Nothing -> return NoInstance ;
 	    Just (dfun_id, mb_inst_tys) -> do
hunk ./compiler/typecheck/Inst.lhs 884
     }}}}
 
 ---------------
-lookupPred :: TcPredType -> TcM (Maybe (DFunId, [Either TyVar TcType]))
+applyContextConstraints _ _ _ _ x@([],_) = return x
+applyContextConstraints _ _ _ _ x@([_],_) = return x
+applyContextConstraints inst availP ies tys (ms,us) = 
+  do ms' <- filterM matchesContext ms
+     return (reduceContextMatches ms', us)
+  where
+    reduceContextMatches [] = []
+    reduceContextMatches [x] = [x]
+    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
+
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    isMostSpecificContext x xs =
+      all (not . thetaProperSubset (theta x)) $ map theta xs
+      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
+
+    thetaProperSubset :: ThetaType -> ThetaType -> Bool
+    thetaProperSubset sub super =
+      all inSuper sub
+      where inSuper c = inP c super
+            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+            cmpPred _ _ = False -- TODO: handle other predicates
+
+            inP _ [] = False
+            inP a (b:_) | a `cmpPred` b = True
+            inP a as = inP a $ tail as
+
+    matchesContext match@(match_inst, _) = 
+      do bools <- mapM matchesPred theta
+         return $ and bools
+      where (_, theta, _, _) = instanceHead match_inst
+            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
+            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+
+            matchesPred pred@(ClassP _ _) =
+              do let (ClassP predC predTys) = substPred subst pred
+                 let lookup = lookupInstEnv ies predC predTys 
+                 res <- applyContextConstraints inst availP ies predTys lookup
+                 case res of
+                   ([x],_) -> instMatchAvailP availP inst x
+                   _       -> return False 
+            matchesPred _ = return False
+
+predClassNames inst =
+  map getName theta 
+  where (_, theta, _, _) = instanceHead inst
+        getName (ClassP cls _) = className cls
+
+matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
+matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
+    { use_stage <- getStage
+    ; checkWellStaged (ptext (sLit "instance for") <+> quotes (ppr pred))
+    		      (topIdLvl dfun_id) (thLevel use_stage)
+
+ 	-- It's possible that not all the tyvars are in
+	-- the substitution, tenv. For example:
+	--	instance C X a => D X where ...
+	-- (presumably there's a functional dependency in class C)
+	-- Hence mb_inst_tys :: Either TyVar TcType 
+
+    ; let inst_tv (Left tv)  = do { tv' <- tcInstTyVar tv; return (mkTyVarTy tv') }
+	  inst_tv (Right ty) = return ty
+    ; tys <- mapM inst_tv mb_inst_tys
+    ; let
+    	(theta, _) = tcSplitPhiTy (applyTys (idType dfun_id) tys)
+	src_loc	   = instLocSpan loc
+	dfun	   = HsVar dfun_id
+    ; if null theta then
+        return (GenInst [] (L src_loc $ HsWrap (mkWpTyApps tys) dfun))
+      else do
+    { (dict_app, dicts) <- getLIE $ instCallDicts loc theta -- !!!
+    ; let co_fn = dict_app <.> mkWpTyApps tys
+    ; return (GenInst dicts (L src_loc $ HsWrap co_fn dfun))
+    }}
+
+returnInsts (ispec, inst_tys) = (is_dfun ispec, inst_tys)
+
+maybeGenInst gi@(GenInst dicts _) = Just gi
+maybeGenInst _                    = Nothing
+
+lookupInstResultAvailP :: (Inst -> TcM Bool) -> LookupInstResult -> TcM Bool
+lookupInstResultAvailP availP (GenInst dicts _) =
+  do avails <- mapM availP dicts
+     return $ and avails
+
+--instMatchAvailP :: (Inst -> TcM Bool) -> Inst -> InstMatch -> TcM Bool
+instMatchAvailP availP inst match =
+  do match' <- matchInst inst $ returnInsts match
+     lookupInstResultAvailP availP match'
+     
+-- an instance with zero type variables is THE best match
+-- an instance is "a best match" if no other instance has
+-- all its predicates and more
+bestInstMatches [] = []
+bestInstMatches [x] = [x]
+bestInstMatches (x:xs) = collectMostSpecificContexts [] x xs 
+  where
+--    collectMostSpecificContexts _ x _
+--      | noTypeVariables x
+--        = [x]
+--
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    noTypeVariables x = null $ tyVars x
+    tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
+  
+-- this is a naive match method.  it has no knowledge
+-- of which type variables a pred is predicating.  
+-- so (A a, A b, C c) is a proper subset of (A a, B b, C c),
+-- which is not true.  However, I can't figure out why tcEqPred
+-- always fails on type variables.  Needs unification? Maybe tcMatchTys?
+thetaProperSubset :: ThetaType -> ThetaType -> Bool
+thetaProperSubset subTheta superTheta =
+  -- NO pred exists strictly more times in sub than in super
+  -- SOME pred exists less times in sub than in super 
+
+  (not $ any (hasLess super sub) combined) && (any (hasLess sub super) combined)
+
+  where hasLess t1 t2 c = (count c t1) < (count c t2)
+
+        cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+        cmpPred _ _ = False -- TODO: handle other predicates
+
+        count _ [] = 0
+        count a (b:bs) | a `cmpPred` b = 1 + (count a bs)
+                       | otherwise     = count a bs
+
+        sub = filter isClassPred subTheta
+        super = filter isClassPred superTheta
+
+        combined = sub ++ super
+
+
+--thetaProperSubset :: ThetaType -> ThetaType -> Bool
+--thetaProperSubset sub super =
+--  (all (hasP super) sub) && (not $ all (hasP sub) super)
+--  where hasP [] _ = False
+--        hasP (b:bs) a | tcEqPred a b = True
+--                      | otherwise    = hasP bs a
+--
+isMoreSpecificInst x y =
+    not $ thetaProperSubset (theta x) (theta y)
+  where theta = instanceTheta.fst
+
+instanceTheta = (\(_,x,_,_) -> x) . instanceHead 
+instanceTyVars = (\(x,_,_,_) -> x) . instanceHead
+
+isMostSpecificContext x xs 
+--  | null $ tyVars x
+--    = True
+--  | otherwise
+    = all (isMoreSpecificInst x) xs
+  where tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
+        xs' = filter (\y -> not $ tcEqTheta (theta x) (theta y)) xs
+        theta = instanceTheta.fst
+
+eqLength x y = (length x) == (length y)
+
+zipWith' f x y
+  | eqLength x y
+    = and $ zipWith f x y
+  | otherwise
+    = False
+
+tcEqTheta = zipWith' eqVarNamesPred
+
+eqVarNamesPred (ClassP c1 vs1) (ClassP c2 vs2) 
+  = c1 == c2 && vs1 `eqVarNamesTypes` vs2
+eqVarNamesPred _ _ = False
+
+eqVarNamesTypes = zipWith' eqVarNamesType
+
+eqVarNamesType (TyVarTy tv1) (TyVarTy tv2) = tv1 `eqVarNamesVar` tv2
+eqVarNamesType (AppTy f1 a1) (AppTy f2 a2) = f1 `eqVarNamesType` f2 && a1 `eqVarNamesType` a2
+eqVarNamesType (TyConApp c1 tys1) (TyConApp c2 tys2) = c1 == c2 && tys1 `eqVarNamesTypes` tys2
+eqVarNamesType (FunTy f1 a1) (FunTy f2 a2) = f1 `eqVarNamesType` f2 && a1 `eqVarNamesType` a2
+eqVarNamesType (ForAllTy tv1 ty1) (ForAllTy tv2 ty2) = tv1 `eqVarNamesVar` tv2 && ty1 `eqVarNamesType` ty2
+
+eqVarNamesVar x y = (getName x) == (getName y)
+
+
+checkAvail _ _ x@([],_) = return x
+checkAvail _ _ x@([_],_) = return x
+checkAvail availP inst (insts,unifs) = 
+  do insts' <- filterM (instMatchAvailP availP inst) insts
+     return (insts', unifs)
+
+tcEqInstMatch' (i1, tys1) (i2, tys2) 
+  = tcEqTheta theta1 theta2
+    where theta1 = instanceTheta i1
+          theta2 = instanceTheta i2
+
+tcEqInstMatch (i1, _) (i2, _) 
+  = case mkInstTypeMap i1 i2 of
+    Nothing -> False
+    (Just tvMap) -> tcEqTheta theta1 theta2
+      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+            -- theta1 = instanceTheta i1
+            theta2 = instanceTheta i2
+
+tcEqInstMatch'' (i1,_) (i2,_)
+  = tcEqTheta theta1 theta2
+  where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+        theta2 = instanceTheta i2
+        tvMap = zip tvs1 tvs2
+        tvs1 = instanceTyVars i1
+        tvs2 = instanceTyVars i2
+
+mapTheta (i1, tys1) (i2, tys2) 
+  = case mkInstTypeMap tys1 tys2 of
+    Nothing -> []
+    (Just tvMap) -> theta1 
+      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+
+mapTyVarsPreds tvMap = map (mapTyVarsPred tvMap) 
+mapTyVarsPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsTypes tvMap tys
+
+mapTyVarsTypes :: [(TyVar,TyVar)] -> [Type] -> [Type]
+mapTyVarsTypes tvMap tys = map (mapTyVarsType tvMap) tys
+
+mapTyVarsType tvMap (TyVarTy tv) 
+  = TyVarTy $ mapTyVar tvMap tv
+
+mapTyVarsType tvMap (AppTy ty1 ty2) 
+  = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+
+mapTyVarsType tvMap (TyConApp tc tys)
+  = TyConApp tc $ mapTyVarsTypes tvMap tys
+
+mapTyVarsType tvMap (FunTy ty1 ty2)
+  = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+
+mapTyVarsType tvMap (ForAllTy tv ty)
+  = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
+
+mapTyVarsType tvMap (PredTy pred)
+  = PredTy $ mapTyVarsPred tvMap pred
+
+mapTyVar :: [(TyVar, TyVar)] -> TyVar -> TyVar
+mapTyVar tvMap tv 
+  = case lookup' tv of
+    Just tv' -> tv'
+    Nothing  -> tv
+  where lookup' tv1 = find (\(tv2,res) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+
+mkInstTypeMap i1 i2
+  | (length tvs1) == (length tvs2)
+    = Just $ filter (\(v1, v2) -> not $ eqVarNamesVar v1 v2) $ zip tvs1 tvs2
+  | otherwise
+    = Nothing
+  where tvs1 = instanceTyVars i1
+        tvs2 = instanceTyVars i2
+
+--mkInstTypeMap :: [Either TyVar Type] -> [Either TyVar Type] -> Maybe [(TyVar,TyVar)]
+--mkInstTypeMap tys1 tys2 = foldM matchLeft [] $ zip tys1 tys2
+--  where matchLeft ms (Left tv1, Left tv2) = Just ((tv1,tv2):ms)
+--        matchLeft _ _                     = Nothing
+
+-- should always be the same length
+tcEqInstTypes [] [] = True
+tcEqInstTypes (x:xs) (y:ys) = tcEqInstType x y && tcEqInstTypes xs ys
+
+tcEqInstType (Left _) (Right _) = False
+tcEqInstType (Right _) (Left _) = False
+tcEqInstType (Left _) (Left _) = True
+tcEqInstType (Right ty1) (Right ty2) = tcEqType ty1 ty2
+
+testInstMatchCompare [] = return ()
+testInstMatchCompare (inst:rest) =
+  do { mapM (testInstMatchCompare' inst) rest
+     ; testInstMatchCompare rest }
+
+testInstMatchCompare' m1@(i1,_) m2@(i2,_) =  
+  do { traceTc (text "MATT: COMPARING INSTS" <+> (ppr [m1,m2]))
+     ; let tys1 = instanceTyVars i1
+     ; let tys2 = instanceTyVars i2
+
+     ; traceTc (text "INST1 VARS: " <+> (ppr tys1))
+     ; traceTc (text "INST2 VARS: " <+> (ppr tys2))
+     ; case tcEqInstMatch m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch OK" )
+     ; case tcEqInstMatch' m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch' FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch' OK" )
+     ; case tcEqInstMatch'' m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch'' FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch'' OK" )
+     ; return () }
+  
+
+removeDuplicates [] = []
+removeDuplicates [a] = [a]
+removeDuplicates (a:as)
+  | isDuplicate a = removeDuplicates as
+  | otherwise     = a:(removeDuplicates as)
+  where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
+--        cmp (i1,_) (i2,_) = (theta i1) `tcEqTheta` (theta i2)
+--        theta = (\(_,t,_,_)->t).instanceHead
+
+lookupPred :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
hunk ./compiler/typecheck/Inst.lhs 1206
-lookupPred pred@(ClassP clas tys)
-  = do	{ eps     <- getEps
+lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys), tci_loc = loc})
+  = do	{ ; eps     <- getEps
 	; tcg_env <- getGblEnv
 	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
hunk ./compiler/typecheck/Inst.lhs 1210
-	; case lookupInstEnv inst_envs clas tys of {
+	; let insts = lookupInstEnv inst_envs clas tys 
+  ; let (inst_matches, inst_unifs) = insts
+  ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
+
+	-- TODO: check for ContextConstraints flag
+  case force of
+      True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
+      False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
+  ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
+	; constrained <- applyContextConstraints inst availP inst_envs tys insts 
+  ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
+  ; avail_insts <- checkAvail availP inst insts
+  ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
+  ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
+  ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
+	; avail_insts' <- applyContextConstraints inst availP inst_envs tys avail_insts
+  ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
+  ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
+  ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
+  ; testInstMatchCompare $ fst both_dupes
+  ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
+  ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
+  ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
+  ; traceTc (text "MATT: BEST OF BOTH WORLDS" <+> (ppr best_both))
+  ; let (best_matches, _) = best_both
+  ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
+  ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
+  ; let final = case (not force) && (isTyVarDict inst) of
+                     -- if there are unconstrained type vars, don't decide yet
+                     -- XXX This is a hack, and *should not* work in general
+                     True -> (best_possible, [])
+
+                     -- time to decide. pick the best match(es).  No guarantee we're not still
+                     -- deciding too early.
+                     False -> best_both 
+  ; traceTc (text "MATT: DONE: " <+> (ppr final))
+	; case final of {
 	    ([(ispec, inst_tys)], []) 
 		-> do	{ let dfun_id = is_dfun ispec
 			; traceTc (text "lookupInst success" <+> 
hunk ./compiler/typecheck/Inst.lhs 1270
 			; return Nothing }
 	}}
 
-lookupPred (IParam {}) = return Nothing	-- Implicit parameters
-lookupPred (EqPred {}) = panic "lookupPred EqPred"
+lookupPred _ _ (Dict {tci_pred = (IParam {})}) = return Nothing	-- Implicit parameters
+lookupPred _ _ (Dict {tci_pred = (EqPred {})}) = panic "lookupPred EqPred"
 
 record_dfun_usage :: Id -> TcRn ()
 record_dfun_usage dfun_id 
hunk ./compiler/typecheck/TcSimplify.lhs 62
 
 import Control.Monad
 import Data.List
+import Data.Maybe
 \end{code}
 
 
hunk ./compiler/typecheck/TcSimplify.lhs 1036
         }
 
 -----------------------------------------------------------
+tryReallyHardCheckLoop :: SDoc
+	     -> [Inst]			-- Wanted
+	     -> TcM ([Inst], TcDictBinds)
+
+tryReallyHardCheckLoop doc wanteds
+  = do { (irreds,binds) <- forceCheckLoop (mkInferRedEnv doc try_me) wanteds
+       ; return (irreds,binds)
+       }
+  where
+    try_me _ = ReduceMe
+	-- Here's the try-hard bit
+
 tryHardCheckLoop :: SDoc
 	     -> [Inst]			-- Wanted
 	     -> TcM ([Inst], TcDictBinds)
hunk ./compiler/typecheck/TcSimplify.lhs 1115
 
 \begin{code}
 -----------------------------------------------------------
+checkLoop' True = forceCheckLoop
+checkLoop' False = checkLoop
+
+forceCheckLoop :: RedEnv
+	  -> [Inst]			-- Wanted
+	  -> TcM ([Inst], TcDictBinds) 
+-- Precondition: givens are completely rigid
+-- Postcondition: returned Insts are zonked
+
+forceCheckLoop env wanteds
+  = go env wanteds
+  where go env wanteds
+	  = do  {  -- We do need to zonk the givens; cf Note [Zonking RedEnv]
+                ; traceTc (text "MATT: entering forceCheckLoop ")
+                ; env'     <- zonkRedEnv env
+		; wanteds' <- zonkInsts  wanteds
+	
+		; (improved, tybinds, binds, irreds) 
+                    <- reduceContext env' wanteds'
+                ; execTcTyVarBinds tybinds
+    --; if null irreds || not improved then
+    ; if not improved then
+        do {
+            ;(improved1, tybinds1, binds1, irreds1)
+                    <- forceReduceContext env' wanteds'
+            ; execTcTyVarBinds tybinds1
+            ; if null irreds1 || not improved1 then
+                do {
+                    ; traceTc (text "MATT: forceCheckLoop exiting")
+                    ; return (irreds1, binds1) }
+              else do { 
+                ; (irreds2, binds2) <- go env' irreds1
+                ; return (irreds2, binds1 `unionBags` binds2) } }
+        else do	
+		-- If improvement did some unification, we go round again.
+		-- We start again with irreds, not wanteds
+		-- Using an instance decl might have introduced a fresh type
+		-- variable which might have been unified, so we'd get an 
+                -- infinite loop if we started again with wanteds!  
+                -- See Note [LOOP]
+		{ (irreds1, binds1) <- go env' irreds
+		; return (irreds1, binds `unionBags` binds1) } }
 checkLoop :: RedEnv
 	  -> [Inst]			-- Wanted
 	  -> TcM ([Inst], TcDictBinds) 
hunk ./compiler/typecheck/TcSimplify.lhs 1167
   = go env wanteds
   where go env wanteds
 	  = do  {  -- We do need to zonk the givens; cf Note [Zonking RedEnv]
+                ; traceTc (text "MATT: entering checkLoop ")
                 ; env'     <- zonkRedEnv env
 		; wanteds' <- zonkInsts  wanteds
 	
hunk ./compiler/typecheck/TcSimplify.lhs 1176
                 ; execTcTyVarBinds tybinds
 
 		; if null irreds || not improved then
-	 	    return (irreds, binds)
+        do {
+            ; traceTc (text "MATT: checkLoop exiting")
+	 	        ; return (irreds, binds) }
 		  else do
 	
 		-- If improvement did some unification, we go round again.
hunk ./compiler/typecheck/TcSimplify.lhs 1680
 	| otherwise
 	= do { w' <- zonkInst w  -- So that (3::Int) does not generate a call
 				 -- to fromInteger; this looks fragile to me
-	     ; lookup_result <- lookupSimpleInst w'
+	     ; lookup_result <- lookupSimpleInst False (\_ -> return False) w'
 	     ; case lookup_result of
 		 NoInstance      -> go (w:irreds) binds ws
 		 GenInst ws' rhs -> go irreds binds' (ws' ++ ws)
hunk ./compiler/typecheck/TcSimplify.lhs 1942
 		      TcDictBinds,	-- Dictionary bindings
 		      [Inst])		-- Irreducible
 
-reduceContext env wanteds0
-  = do	{ traceTc (text "reduceContext" <+> (vcat [
+reduceContext = reduceContext' False
+forceReduceContext = reduceContext' True
+reduceContext' force env wanteds0
+  = do	{ 
+    ;if force then traceTc (text "MATT: reduceContext' FORCE")
+      else traceTc (text "MATT reduceContext'")
+   ;traceTc (text "reduceContext" <+> (vcat [
 	     text "----------------------",
 	     red_doc env,
 	     text "given" <+> ppr (red_givens env),
hunk ./compiler/typecheck/TcSimplify.lhs 1987
           -- of improvement due to functional dependencies if any of the
           -- involved unifications gets deferred.
 	; let (wanted_implics, wanted_dicts) = partition isImplicInst wanteds'
-	; (avails, extra_eqs) <- getLIE (reduceList env wanted_dicts init_state)
+	; (avails, extra_eqs) <- getLIE (reduceList' force env wanted_dicts init_state)
 	  	   -- The getLIE is reqd because reduceList does improvement
 		   -- (via extendAvails) which may in turn do unification
 	; (dict_binds, 
hunk ./compiler/typecheck/TcSimplify.lhs 2007
                                    = givens ++ bound_dicts ++
                                      map wantedToLocalEqInst dict_irreds }
 	; (implic_binds_s, implic_irreds_s) 
-            <- mapAndUnzipM (reduceImplication implic_env) wanted_implics
+            <- mapAndUnzipM (reduceImplication' force implic_env) wanted_implics
 	; let implic_binds  = unionManyBags implic_binds_s
 	      implic_irreds = concat implic_irreds_s
 
hunk ./compiler/typecheck/TcSimplify.lhs 2035
               improvedHint  = (if avails_improved then " [AVAILS]" else "") ++
                               (if eq_improved then " [EQ]" else "")
 
+  ; if force then traceTc (text "MATT: reduceContext FORCE")
+  else traceTc (text "MATT: reduceContext FORCE")
 	; traceTc (text "reduceContext end" <+> (vcat [
 	     text "----------------------",
 	     red_doc env,
hunk ./compiler/typecheck/TcSimplify.lhs 2158
 The main context-reduction function is @reduce@.  Here's its game plan.
 
 \begin{code}
-reduceList :: RedEnv -> [Inst] -> Avails -> TcM Avails
-reduceList env@(RedEnv {red_stack = (n,stk)}) wanteds state
-  = do	{ traceTc (text "reduceList " <+> (ppr wanteds $$ ppr state))
+--reduceList :: RedEnv -> [Inst] -> Avails -> TcM Avails
+--reduceList = reduceList' False
+reduceList' force env@(RedEnv {red_stack = (n,stk)}) wanteds state
+  = do	{ 
+  ; (case force of
+      True -> traceTc (text "reduceList (FORCE) " <+> (ppr wanteds $$ ppr state))
+      False -> traceTc (text "reduceList " <+> (ppr wanteds $$ ppr state)))
 	; dopts <- getDOpts
 	; when (debugIsOn && (n > 8)) $ do
 		debugDumpTcRn (hang (ptext (sLit "Interesting! Context reduction stack depth") <+> int n) 
hunk ./compiler/typecheck/TcSimplify.lhs 2175
 	    go wanteds state }
   where
     go []     state = return state
-    go (w:ws) state = do { state' <- reduce (env {red_stack = (n+1, w:stk)}) w state
+    go (w:ws) state = do { state' <- reduce' force (env {red_stack = (n+1, w:stk)}) w state
 			 ; go ws state' }
 
     -- Base case: we're done!
hunk ./compiler/typecheck/TcSimplify.lhs 2180
 reduce :: RedEnv -> Inst -> Avails -> TcM Avails
-reduce env wanted avails
+reduce = reduce' False
+reduce' force env wanted avails
 
     -- We don't reduce equalities here (and they must not end up as irreds
     -- in the Avails!)
hunk ./compiler/typecheck/TcSimplify.lhs 2195
        }
 
   | otherwise
-  = do	{ traceTc (text "reduce" <+> ppr wanted $$ ppr avails)
+  = do	{ 
+  ; (case force of 
+      True -> traceTc (text "reduce (FORCE)" <+> ppr wanted $$ ppr avails)
+      False -> traceTc (text "reduce" <+> ppr wanted $$ ppr avails))
 	; case red_try_me env wanted of {
 	    Stop -> try_simple (addIrred NoSCs);
 			-- See Note [No superclasses for Stop]
hunk ./compiler/typecheck/TcSimplify.lhs 2204
 
 	    ReduceMe -> do	-- It should be reduced
-		{ (avails, lookup_result) <- reduceInst env avails wanted
+		{ (avails, lookup_result) <- reduceInst force env avails wanted
 		; case lookup_result of
 		    NoInstance -> addIrred AddSCs avails wanted
 			     -- Add it and its superclasses
hunk ./compiler/typecheck/TcSimplify.lhs 2213
 
 		    GenInst wanteds' rhs
 			  -> do	{ avails1 <- addIrred NoSCs avails wanted
-				; avails2 <- reduceList env wanteds' avails1
+				; avails2 <- reduceList' force env wanteds' avails1
 				; addWanted AddSCs avails2 wanted rhs wanteds' } }
 		-- Temporarily do addIrred *before* the reduceList, 
 		-- which has the effect of adding the thing we are trying
hunk ./compiler/typecheck/TcSimplify.lhs 2229
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst wanted
+      = do { res <- lookupSimpleInst force (return . isJust . findAvail avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
hunk ./compiler/typecheck/TcSimplify.lhs 2322
 
 \begin{code}
 ---------------------------------------------
-reduceInst :: RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
-reduceInst _ avails other_inst
-  = do	{ result <- lookupSimpleInst other_inst
+reduceInst :: Bool -> RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
+reduceInst force _ avails other_inst
+  = do	{ result <- lookupSimpleInst force (return . isJust . findAvail avails) other_inst
 	; return (avails, result) }
 \end{code}
 
hunk ./compiler/typecheck/TcSimplify.lhs 2400
         -- where cotv is a simple coercion type variable (and not a more
         -- complex coercion term).  We require that the extra_givens always
         -- have this form and exploit the special form when generating binders.
-reduceImplication env
+reduceImplication = reduceImplication' False
+reduceImplication' force env
 	orig_implic@(ImplicInst { tci_name = name, tci_loc = inst_loc,
 		      	   	  tci_tyvars = tvs,
 		      	   	  tci_given = extra_givens, tci_wanted = wanteds
hunk ./compiler/typecheck/TcSimplify.lhs 2418
 	; traceTc (text "reduceImplication" <+> vcat
 			[ ppr (red_givens env), ppr extra_givens, 
 			  ppr wanteds])
-	; (irreds, binds) <- checkLoop env' wanteds
+	; (irreds, binds) <- checkLoop' force env' wanteds
 
 	; traceTc (text "reduceImplication result" <+> vcat
 			[ppr irreds, ppr binds])
hunk ./compiler/typecheck/TcSimplify.lhs 2483
 		  simpler_implic_insts)
   	} 
     }
-reduceImplication _ i = pprPanic "reduceImplication" (ppr i)
+reduceImplication' _ _ i = pprPanic "reduceImplication" (ppr i)
 \end{code}
 
 Note [Always inline implication constraints]
hunk ./compiler/typecheck/TcSimplify.lhs 2857
 	; mapM_ zonkTopTyVar (varSetElems (tyVarsOfInsts wanteds))
 
 	; traceTc (text "tc_simplify_top 0: " <+> ppr wanteds)
-	; (irreds1, binds1) <- tryHardCheckLoop doc1 wanteds
+	; (irreds1, binds1) <- tryReallyHardCheckLoop doc1 wanteds
 --	; (irreds1, binds1) <- gentleInferLoop doc1 wanteds
 	; traceTc (text "tc_simplify_top 1: " <+> ppr irreds1)
 	; (irreds2, binds2) <- approximateImplications doc2 (\_ -> True) irreds1
hunk ./compiler/types/InstEnv.lhs 36
 import UniqFM
 import Id
 import FastString
-import Type (substPred)
 
 import Data.Maybe	( isJust, isNothing )
 \end{code}
hunk ./compiler/types/InstEnv.lhs 449
     (pkg_matches,  pkg_unifs)  = lookup pkg_ie  
     all_matches = home_matches ++ pkg_matches
     all_unifs   = home_unifs   ++ pkg_unifs
-    pruned_matches = applyContextConstraints $ foldr insert_overlapping [] all_matches
+    pruned_matches = foldr insert_overlapping [] all_matches
 	-- Even if the unifs is non-empty (an error situation)
 	-- we still prune the matches, so that the error message isn't
 	-- misleading (complaining of multiple matches when some should be
hunk ./compiler/types/InstEnv.lhs 455
 	-- overlapped away)
 
-    --------------
-    applyContextConstraints x@(_:_:_) = reduceContextMatches $ filter matchesContext x
-    applyContextConstraints x = x
-
-    reduceContextMatches [] = []
-    reduceContextMatches [x] = [x]
-    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
-
-    collectMostSpecificContexts outs x []
-      | isMostSpecificContext x outs
-        = x:outs
-      | otherwise
-        = outs
-
-    collectMostSpecificContexts outs x ins@(x':ins')
-      | isMostSpecificContext x (outs ++ ins)
-        = collectMostSpecificContexts (x:outs) x' ins'
-      | otherwise
-        = collectMostSpecificContexts outs x' ins'
-
-    thetaProperSubset :: ThetaType -> ThetaType -> Bool
-    thetaProperSubset sub super =
-      all inSuper sub
-      where inSuper c = inP c super
-            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
-            cmpPred _ _ = False -- TODO: handle other predicates
-
-            inP _ [] = False
-            inP a (b:_) | a `cmpPred` b = True
-            inP a as = inP a $ tail as
-
-    isMostSpecificContext x xs =
-      all (not . thetaProperSubset (theta x)) $ map theta xs
-      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
-
-    matchesContext (match_inst, _) = 
-      all matchesPred theta
-      where (_, theta, _, _) = instanceHead match_inst
-            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
-            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
-
-            matchesPred pred@(ClassP _ _) = 
-              case lookupInstEnv (pkg_ie, home_ie) predC predTys of
-                   ([_],_) -> True
-                   (_,_) -> False
-              where (ClassP predC predTys) = substPred subst pred
-            matchesPred _ = False
-
     --------------
     lookup env = case lookupUFM env cls of
 		   Nothing -> ([],[])	-- No instances for this class
}
[Partial Cleanup
matt@softmechanics.net**20100316180520
 Ignore-this: 842291f863dbd182678882279c91abd6
] {
hunk ./compiler/typecheck/Inst.lhs 884
     }}}}
 
 ---------------
+applyContextConstraints :: Inst -> 
+                           (Inst -> TcM Bool) -> 
+                           (InstEnv, InstEnv) -> 
+                           [Type] -> 
+                           ([(Instance,[Either TyVar Type])], [Instance]) -> 
+                           IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
 applyContextConstraints _ _ _ _ x@([],_) = return x
 applyContextConstraints _ _ _ _ x@([_],_) = return x
 applyContextConstraints inst availP ies tys (ms,us) = 
hunk ./compiler/typecheck/Inst.lhs 894
   do ms' <- filterM matchesContext ms
-     return (reduceContextMatches ms', us)
+     return (bestInstMatches ms', us)
   where
hunk ./compiler/typecheck/Inst.lhs 896
-    reduceContextMatches [] = []
-    reduceContextMatches [x] = [x]
-    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
-
-    collectMostSpecificContexts outs x []
-      | isMostSpecificContext x outs
-        = x:outs
-      | otherwise
-        = outs
-
-    collectMostSpecificContexts outs x ins@(x':ins')
-      | isMostSpecificContext x (outs ++ ins)
-        = collectMostSpecificContexts (x:outs) x' ins'
-      | otherwise
-        = collectMostSpecificContexts outs x' ins'
-
-    isMostSpecificContext x xs =
-      all (not . thetaProperSubset (theta x)) $ map theta xs
-      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
-
-    thetaProperSubset :: ThetaType -> ThetaType -> Bool
-    thetaProperSubset sub super =
-      all inSuper sub
-      where inSuper c = inP c super
-            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
-            cmpPred _ _ = False -- TODO: handle other predicates
-
-            inP _ [] = False
-            inP a (b:_) | a `cmpPred` b = True
-            inP a as = inP a $ tail as
-
-    matchesContext match@(match_inst, _) = 
-      do bools <- mapM matchesPred theta
+    matchesContext (match_inst, _) = 
+      do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
+         traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
+         bools <- mapM matchesPred theta
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
hunk ./compiler/typecheck/Inst.lhs 904
             (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+            theta' = map (substPred subst) theta
 
             matchesPred pred@(ClassP _ _) =
               do let (ClassP predC predTys) = substPred subst pred
hunk ./compiler/typecheck/Inst.lhs 909
                  let lookup = lookupInstEnv ies predC predTys 
+                 traceTc (text "MATT: matchesPred matches" <+> (ppr lookup))
                  res <- applyContextConstraints inst availP ies predTys lookup
hunk ./compiler/typecheck/Inst.lhs 911
+                 traceTc (text "MATT: matchesPred constrained matches" <+> (ppr res))
                  case res of
                    ([x],_) -> instMatchAvailP availP inst x
                    _       -> return False 
hunk ./compiler/typecheck/Inst.lhs 917
             matchesPred _ = return False
 
-predClassNames inst =
-  map getName theta 
-  where (_, theta, _, _) = instanceHead inst
-        getName (ClassP cls _) = className cls
-
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
     { use_stage <- getStage
hunk ./compiler/typecheck/Inst.lhs 944
     ; return (GenInst dicts (L src_loc $ HsWrap co_fn dfun))
     }}
 
-returnInsts (ispec, inst_tys) = (is_dfun ispec, inst_tys)
-
-maybeGenInst gi@(GenInst dicts _) = Just gi
-maybeGenInst _                    = Nothing
-
 lookupInstResultAvailP :: (Inst -> TcM Bool) -> LookupInstResult -> TcM Bool
 lookupInstResultAvailP availP (GenInst dicts _) =
   do avails <- mapM availP dicts
hunk ./compiler/typecheck/Inst.lhs 949
      return $ and avails
 
---instMatchAvailP :: (Inst -> TcM Bool) -> Inst -> InstMatch -> TcM Bool
-instMatchAvailP availP inst match =
-  do match' <- matchInst inst $ returnInsts match
+instMatchAvailP :: (Inst -> TcM Bool) -> 
+                   Inst -> 
+                   (Instance, [Either TyVar TcType]) -> 
+                   IOEnv (Env TcGblEnv TcLclEnv) Bool
+instMatchAvailP availP inst (ispec, inst_tys) =
+  do match' <- matchInst inst (is_dfun ispec, inst_tys)
      lookupInstResultAvailP availP match'
      
hunk ./compiler/typecheck/Inst.lhs 957
--- an instance with zero type variables is THE best match
--- an instance is "a best match" if no other instance has
--- all its predicates and more
+bestInstMatches :: [(Instance, [Either TyVar Type])] -> [(Instance, [Either TyVar Type])]
 bestInstMatches [] = []
 bestInstMatches [x] = [x]
 bestInstMatches (x:xs) = collectMostSpecificContexts [] x xs 
hunk ./compiler/typecheck/Inst.lhs 962
   where
---    collectMostSpecificContexts _ x _
---      | noTypeVariables x
---        = [x]
---
     collectMostSpecificContexts outs x []
       | isMostSpecificContext x outs
         = x:outs
hunk ./compiler/typecheck/Inst.lhs 973
         = collectMostSpecificContexts (x:outs) x' ins'
       | otherwise
         = collectMostSpecificContexts outs x' ins'
-
-    noTypeVariables x = null $ tyVars x
-    tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
   
hunk ./compiler/typecheck/Inst.lhs 974
--- this is a naive match method.  it has no knowledge
--- of which type variables a pred is predicating.  
--- so (A a, A b, C c) is a proper subset of (A a, B b, C c),
--- which is not true.  However, I can't figure out why tcEqPred
--- always fails on type variables.  Needs unification? Maybe tcMatchTys?
 thetaProperSubset :: ThetaType -> ThetaType -> Bool
 thetaProperSubset subTheta superTheta =
   -- NO pred exists strictly more times in sub than in super
hunk ./compiler/typecheck/Inst.lhs 995
 
         combined = sub ++ super
 
-
---thetaProperSubset :: ThetaType -> ThetaType -> Bool
---thetaProperSubset sub super =
---  (all (hasP super) sub) && (not $ all (hasP sub) super)
---  where hasP [] _ = False
---        hasP (b:bs) a | tcEqPred a b = True
---                      | otherwise    = hasP bs a
---
-isMoreSpecificInst x y =
-    not $ thetaProperSubset (theta x) (theta y)
+isMoreSpecificInst :: (Instance, [Either TyVar Type]) -> (Instance, [Either TyVar Type]) -> Bool
+isMoreSpecificInst x y 
+    = not $ thetaProperSubset (theta x) (theta y)
   where theta = instanceTheta.fst
 
hunk ./compiler/typecheck/Inst.lhs 1000
+instanceTheta :: Instance -> ThetaType
 instanceTheta = (\(_,x,_,_) -> x) . instanceHead 
hunk ./compiler/typecheck/Inst.lhs 1002
+instanceTyVars :: Instance -> [TyVar]
 instanceTyVars = (\(x,_,_,_) -> x) . instanceHead
 
hunk ./compiler/typecheck/Inst.lhs 1005
+isMostSpecificContext :: (Instance, [Either TyVar Type])
+                      -> [(Instance, [Either TyVar Type])]
+                      -> Bool
 isMostSpecificContext x xs 
hunk ./compiler/typecheck/Inst.lhs 1009
---  | null $ tyVars x
---    = True
---  | otherwise
     = all (isMoreSpecificInst x) xs
hunk ./compiler/typecheck/Inst.lhs 1010
-  where tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
-        xs' = filter (\y -> not $ tcEqTheta (theta x) (theta y)) xs
-        theta = instanceTheta.fst
-
-eqLength x y = (length x) == (length y)
 
hunk ./compiler/typecheck/Inst.lhs 1011
+zipWith' :: (a -> a1 -> Bool) -> [a] -> [a1] -> Bool
 zipWith' f x y
   | eqLength x y
     = and $ zipWith f x y
hunk ./compiler/typecheck/Inst.lhs 1017
   | otherwise
     = False
+  where eqLength x y = (length x) == (length y)
 
 tcEqTheta = zipWith' eqVarNamesPred
 
hunk ./compiler/typecheck/Inst.lhs 1021
+eqVarNamesPred :: PredType -> PredType -> Bool
 eqVarNamesPred (ClassP c1 vs1) (ClassP c2 vs2) 
   = c1 == c2 && vs1 `eqVarNamesTypes` vs2
 eqVarNamesPred _ _ = False
hunk ./compiler/typecheck/Inst.lhs 1036
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
-
 checkAvail _ _ x@([],_) = return x
 checkAvail _ _ x@([_],_) = return x
 checkAvail availP inst (insts,unifs) = 
hunk ./compiler/typecheck/Inst.lhs 1042
   do insts' <- filterM (instMatchAvailP availP inst) insts
      return (insts', unifs)
 
-tcEqInstMatch' (i1, tys1) (i2, tys2) 
-  = tcEqTheta theta1 theta2
-    where theta1 = instanceTheta i1
-          theta2 = instanceTheta i2
-
 tcEqInstMatch (i1, _) (i2, _) 
   = case mkInstTypeMap i1 i2 of
     Nothing -> False
hunk ./compiler/typecheck/Inst.lhs 1047
     (Just tvMap) -> tcEqTheta theta1 theta2
       where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-            -- theta1 = instanceTheta i1
             theta2 = instanceTheta i2
 
hunk ./compiler/typecheck/Inst.lhs 1049
-tcEqInstMatch'' (i1,_) (i2,_)
-  = tcEqTheta theta1 theta2
-  where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-        theta2 = instanceTheta i2
-        tvMap = zip tvs1 tvs2
-        tvs1 = instanceTyVars i1
-        tvs2 = instanceTyVars i2
-
-mapTheta (i1, tys1) (i2, tys2) 
-  = case mkInstTypeMap tys1 tys2 of
-    Nothing -> []
-    (Just tvMap) -> theta1 
-      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-
 mapTyVarsPreds tvMap = map (mapTyVarsPred tvMap) 
 mapTyVarsPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsTypes tvMap tys
 
hunk ./compiler/typecheck/Inst.lhs 1055
 mapTyVarsTypes :: [(TyVar,TyVar)] -> [Type] -> [Type]
 mapTyVarsTypes tvMap tys = map (mapTyVarsType tvMap) tys
 
-mapTyVarsType tvMap (TyVarTy tv) 
-  = TyVarTy $ mapTyVar tvMap tv
-
-mapTyVarsType tvMap (AppTy ty1 ty2) 
-  = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
-
-mapTyVarsType tvMap (TyConApp tc tys)
-  = TyConApp tc $ mapTyVarsTypes tvMap tys
-
-mapTyVarsType tvMap (FunTy ty1 ty2)
-  = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
-
-mapTyVarsType tvMap (ForAllTy tv ty)
-  = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
-
-mapTyVarsType tvMap (PredTy pred)
-  = PredTy $ mapTyVarsPred tvMap pred
+mapTyVarsType tvMap (TyVarTy tv) = TyVarTy $ mapTyVar tvMap tv
+mapTyVarsType tvMap (AppTy ty1 ty2) = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+mapTyVarsType tvMap (TyConApp tc tys) = TyConApp tc $ mapTyVarsTypes tvMap tys
+mapTyVarsType tvMap (FunTy ty1 ty2) = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+mapTyVarsType tvMap (ForAllTy tv ty) = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
+mapTyVarsType tvMap (PredTy pred) = PredTy $ mapTyVarsPred tvMap pred
 
 mapTyVar :: [(TyVar, TyVar)] -> TyVar -> TyVar
 mapTyVar tvMap tv 
hunk ./compiler/typecheck/Inst.lhs 1067
   = case lookup' tv of
     Just tv' -> tv'
     Nothing  -> tv
-  where lookup' tv1 = find (\(tv2,res) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+  where lookup' tv1 = find (\(tv2,_) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
 
hunk ./compiler/typecheck/Inst.lhs 1069
+mkInstTypeMap :: Instance -> Instance -> Maybe [(TyVar, TyVar)]
 mkInstTypeMap i1 i2
   | (length tvs1) == (length tvs2)
     = Just $ filter (\(v1, v2) -> not $ eqVarNamesVar v1 v2) $ zip tvs1 tvs2
hunk ./compiler/typecheck/Inst.lhs 1078
   where tvs1 = instanceTyVars i1
         tvs2 = instanceTyVars i2
 
---mkInstTypeMap :: [Either TyVar Type] -> [Either TyVar Type] -> Maybe [(TyVar,TyVar)]
---mkInstTypeMap tys1 tys2 = foldM matchLeft [] $ zip tys1 tys2
---  where matchLeft ms (Left tv1, Left tv2) = Just ((tv1,tv2):ms)
---        matchLeft _ _                     = Nothing
-
 -- should always be the same length
hunk ./compiler/typecheck/Inst.lhs 1079
-tcEqInstTypes [] [] = True
+tcEqInstTypes [] []         = True
 tcEqInstTypes (x:xs) (y:ys) = tcEqInstType x y && tcEqInstTypes xs ys
hunk ./compiler/typecheck/Inst.lhs 1081
+tcEqInstTypes _ _           = False
 
 tcEqInstType (Left _) (Right _) = False
 tcEqInstType (Right _) (Left _) = False
hunk ./compiler/typecheck/Inst.lhs 1088
 tcEqInstType (Left _) (Left _) = True
 tcEqInstType (Right ty1) (Right ty2) = tcEqType ty1 ty2
 
-testInstMatchCompare [] = return ()
-testInstMatchCompare (inst:rest) =
-  do { mapM (testInstMatchCompare' inst) rest
-     ; testInstMatchCompare rest }
-
-testInstMatchCompare' m1@(i1,_) m2@(i2,_) =  
-  do { traceTc (text "MATT: COMPARING INSTS" <+> (ppr [m1,m2]))
-     ; let tys1 = instanceTyVars i1
-     ; let tys2 = instanceTyVars i2
-
-     ; traceTc (text "INST1 VARS: " <+> (ppr tys1))
-     ; traceTc (text "INST2 VARS: " <+> (ppr tys2))
-     ; case tcEqInstMatch m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch OK" )
-     ; case tcEqInstMatch' m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch' FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch' OK" )
-     ; case tcEqInstMatch'' m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch'' FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch'' OK" )
-     ; return () }
-  
 
hunk ./compiler/typecheck/Inst.lhs 1089
+removeDuplicates :: [(Instance, [Either TyVar TcType])] -> [(Instance, [Either TyVar TcType])]
 removeDuplicates [] = []
 removeDuplicates [a] = [a]
 removeDuplicates (a:as)
hunk ./compiler/typecheck/Inst.lhs 1096
   | isDuplicate a = removeDuplicates as
   | otherwise     = a:(removeDuplicates as)
   where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
---        cmp (i1,_) (i2,_) = (theta i1) `tcEqTheta` (theta i2)
---        theta = (\(_,t,_,_)->t).instanceHead
 
 lookupPred :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
hunk ./compiler/typecheck/Inst.lhs 1099
-lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys), tci_loc = loc})
+lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys)})
   = do	{ ; eps     <- getEps
 	; tcg_env <- getGblEnv
 	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
hunk ./compiler/typecheck/Inst.lhs 1104
 	; let insts = lookupInstEnv inst_envs clas tys 
-  ; let (inst_matches, inst_unifs) = insts
+  ; let inst_matches = fst insts
   ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
 
 	-- TODO: check for ContextConstraints flag
hunk ./compiler/typecheck/Inst.lhs 1122
   ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
   ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
-  ; testInstMatchCompare $ fst both_dupes
   ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
   ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
}
[Improved force logic in lookupPred
matt@softmechanics.net**20100319172745
 Ignore-this: b8c4d5324d24c1a6f943e679ada79202
] {
hunk ./compiler/typecheck/Inst.lhs 1129
   ; let (best_matches, _) = best_both
   ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
   ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
-  ; let final = case (not force) && (isTyVarDict inst) of
-                     -- if there are unconstrained type vars, don't decide yet
-                     -- XXX This is a hack, and *should not* work in general
-                     True -> (best_possible, [])
-
-                     -- time to decide. pick the best match(es).  No guarantee we're not still
+  ; let final = case force of
+                     -- time to decide. pick the best match(es).
                      -- deciding too early.
hunk ./compiler/typecheck/Inst.lhs 1132
-                     False -> best_both 
+                     True -> best_both 
+                     False -> (best_possible, [])
+
   ; traceTc (text "MATT: DONE: " <+> (ppr final))
 	; case final of {
 	    ([(ispec, inst_tys)], []) 
}
[Use mutual recursion between applyContextConstraints, lookupPred to lookup context predicates
matt@softmechanics.net**20100319214527
 Ignore-this: 9ad83e7df5edc404b5dfd473969cff6a
] {
hunk ./compiler/typecheck/Inst.lhs 896
   do ms' <- filterM matchesContext ms
      return (bestInstMatches ms', us)
   where
-    matchesContext (match_inst, _) = 
+    matchesContext (match_inst, match_tvs) = 
       do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
          traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
hunk ./compiler/typecheck/Inst.lhs 899
-         bools <- mapM matchesPred theta
+         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
+         bools <- mapM matchesPredInst predInsts
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
hunk ./compiler/typecheck/Inst.lhs 907
             (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
             theta' = map (substPred subst) theta
 
-            matchesPred pred@(ClassP _ _) =
-              do let (ClassP predC predTys) = substPred subst pred
-                 let lookup = lookupInstEnv ies predC predTys 
-                 traceTc (text "MATT: matchesPred matches" <+> (ppr lookup))
-                 res <- applyContextConstraints inst availP ies predTys lookup
-                 traceTc (text "MATT: matchesPred constrained matches" <+> (ppr res))
-                 case res of
-                   ([x],_) -> instMatchAvailP availP inst x
-                   _       -> return False 
-            matchesPred _ = return False
+            matchesPredInst predInst =
+              do res <- lookupPred False availP predInst
+                 return $ isJust res
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
}
[New ContextConstraints extension flag
matt@softmechanics.net**20100321182444
 Ignore-this: 3c93280d70b18e47953a315364d000ed
 
 Removed short-circuit logic to always accept a single matched element as properly constrained without checking.  
 Finally added ContextConstraints extension flag.  
 Added param to propagate force flag throughout applyContextConstraints/lookupPred loop.
 Made ContextConstraints always ignore unified instances.
 
] {
hunk ./compiler/main/DynFlags.hs 194
    | Opt_OverlappingInstances
    | Opt_UndecidableInstances
    | Opt_IncoherentInstances
+   | Opt_ContextConstraints
    | Opt_MonomorphismRestriction
    | Opt_MonoPatBinds
    | Opt_MonoLocalBinds
hunk ./compiler/main/DynFlags.hs 1639
   ( "FunctionalDependencies",           Opt_FunctionalDependencies, const Supported ),
   ( "GeneralizedNewtypeDeriving",       Opt_GeneralizedNewtypeDeriving, const Supported ),
   ( "OverlappingInstances",             Opt_OverlappingInstances, const Supported ),
+  ( "ContextConstraints",               Opt_ContextConstraints, const Supported ),
   ( "UndecidableInstances",             Opt_UndecidableInstances, const Supported ),
   ( "IncoherentInstances",              Opt_IncoherentInstances, const Supported ),
   ( "PackageImports",                   Opt_PackageImports, const Supported ),
hunk ./compiler/typecheck/Inst.lhs 756
 		-- OK, now extend the envt
 	; return (extendInstEnv home_ie ispec') }
 
+contextConstraintsEnabled :: TcM Bool
+contextConstraintsEnabled 
+  = do { dflags <- getDOpts
+       ; return $ dopt Opt_ContextConstraints dflags
+  }
+  
 getOverlapFlag :: TcM OverlapFlag
 getOverlapFlag 
   = do 	{ dflags <- getDOpts
hunk ./compiler/typecheck/Inst.lhs 890
     }}}}
 
 ---------------
-applyContextConstraints :: Inst -> 
+applyContextConstraints :: Bool ->
+                           Inst -> 
                            (Inst -> TcM Bool) -> 
                            (InstEnv, InstEnv) -> 
                            [Type] -> 
hunk ./compiler/typecheck/Inst.lhs 897
                            ([(Instance,[Either TyVar Type])], [Instance]) -> 
                            IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
-applyContextConstraints _ _ _ _ x@([],_) = return x
-applyContextConstraints _ _ _ _ x@([_],_) = return x
-applyContextConstraints inst availP ies tys (ms,us) = 
+applyContextConstraints _ _ _ _ _ x@([],_) = return x
+applyContextConstraints force inst availP ies tys (ms,us) = 
   do ms' <- filterM matchesContext ms
hunk ./compiler/typecheck/Inst.lhs 900
+     traceTc (text "MATT: applyContextCosntraints" <+> 
+         vcat [text "tys" <+> ppr tys,
+               text "pred" <+> ppr inst,
+               text "matches" <+> ppr ms,
+               text "constrained" <+> ppr ms',
+               text "unifs" <+> ppr us])
+  
      return (bestInstMatches ms', us)
   where
     matchesContext (match_inst, match_tvs) = 
hunk ./compiler/typecheck/Inst.lhs 910
-      do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
-         traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
-         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
+      do (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
          bools <- mapM matchesPredInst predInsts
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
hunk ./compiler/typecheck/Inst.lhs 919
             theta' = map (substPred subst) theta
 
             matchesPredInst predInst =
-              do res <- lookupPred False availP predInst
+              do res <- lookupPred force availP predInst
                  return $ isJust res
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
hunk ./compiler/typecheck/Inst.lhs 1041
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
-checkAvail _ _ x@([],_) = return x
-checkAvail _ _ x@([_],_) = return x
 checkAvail availP inst (insts,unifs) = 
   do insts' <- filterM (instMatchAvailP availP inst) insts
      return (insts', unifs)
hunk ./compiler/typecheck/Inst.lhs 1115
       True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
       False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
   ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
-	; constrained <- applyContextConstraints inst availP inst_envs tys insts 
+	; constrained <- applyContextConstraints force inst availP inst_envs tys insts 
   ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
   ; avail_insts <- checkAvail availP inst insts
   ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
hunk ./compiler/typecheck/Inst.lhs 1121
   ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
   ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
-	; avail_insts' <- applyContextConstraints inst availP inst_envs tys avail_insts
-  ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
   ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
   ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
hunk ./compiler/typecheck/Inst.lhs 1130
   ; let (best_matches, _) = best_both
   ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
   ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
-  ; let final = case force of
-                     -- time to decide. pick the best match(es).
-                     -- deciding too early.
-                     True -> best_both 
-                     False -> (best_possible, [])
+  ; enabled <- contextConstraintsEnabled
+  ; let final = case enabled of
+                      False -> insts
+                      True -> case force of
+                                  -- time to decide. pick the best match(es).
+                                  True -> (fst best_both, [])
+
+                                  -- still have time to see if we get a better match.
+                                  -- if there is no better match, can decide now
+                                  False -> (best_possible, []) 
 
hunk ./compiler/typecheck/Inst.lhs 1141
+  ; case force of
+      True -> traceTc (text "MATT: LOOKUP DONE (FORCE)" <+> 
+                  vcat [text "pred" <+> ppr pred,
+                        text "final" <+> ppr final])
+      False -> traceTc (text "MATT: LOOKUP DONE" <+> 
+                  vcat [text "pred" <+> ppr pred,
+                        text "final" <+> ppr final])
   ; traceTc (text "MATT: DONE: " <+> (ppr final))
 	; case final of {
 	    ([(ispec, inst_tys)], []) 
hunk ./compiler/typecheck/TcSimplify.lhs 1177
 
 		; if null irreds || not improved then
         do {
-            ; traceTc (text "MATT: checkLoop exiting")
+            ; traceTc (text "MATT: checkLoop exiting" <+>
+                 vcat [text "binds" <+> ppr binds,
+                       text "irreds" <+> ppr irreds])
 	 	        ; return (irreds, binds) }
 		  else do
 	
hunk ./compiler/typecheck/TcSimplify.lhs 2231
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst force (return . isJust . findAvail avails) wanted
+      = do { res <- lookupSimpleInst force (isAvail avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
hunk ./compiler/typecheck/TcSimplify.lhs 2323
 %************************************************************************
 
 \begin{code}
+isAvail :: Avails -> Inst -> TcM Bool
+isAvail avails inst 
+  = do traceTc (text "MATT: isAvail" <+> 
+          vcat [text "inst" <+> (ppr inst)
+               ,text "avails" <+> ppr avails
+               ])
+       traceTc (text "MATT: elemAvails" <+> (ppr $ elemAvails inst avails))
+       let res = findAvail avails inst
+       case res of 
+            Just how -> 
+              do traceTc (text "MATT: isAvail how" <+> (ppr how))
+                 return True
+            Nothing -> 
+              do traceTc (text "MATT: not avail")
+                 return False
+
+
 ---------------------------------------------
 reduceInst :: Bool -> RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
 reduceInst force _ avails other_inst
hunk ./compiler/typecheck/TcSimplify.lhs 2343
-  = do	{ result <- lookupSimpleInst force (return . isJust . findAvail avails) other_inst
+  = do	{ result <- lookupSimpleInst force (isAvail avails) other_inst
 	; return (avails, result) }
 \end{code}
 
}
[Context Constraints: Loop Detection
matt@softmechanics.net**20100324052904
 Ignore-this: fdf9ff40c8de488b3f833a819acc9c4f
 Added some simple loop detection to the context constraints logic.  
] {
hunk ./compiler/typecheck/Inst.lhs 810
   = NoInstance
   | GenInst [Inst] (LHsExpr TcId)	-- The expression and its needed insts
 
-lookupSimpleInst :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM LookupInstResult
+lookupSimpleInst :: Bool -> [Inst] -> Inst -> TcM LookupInstResult
 -- This is "simple" in that it returns NoInstance for implication constraints
 
 -- It's important that lookupInst does not put any new stuff into
hunk ./compiler/typecheck/Inst.lhs 858
     loc = instLocSpan iloc
 
 --------------------- Dictionaries ------------------------
-lookupSimpleInst force availP dct@(Dict {tci_pred = pred, tci_loc = loc})
-  = do 	{ mb_result <- lookupPred force availP dct
+lookupSimpleInst force avails dct@(Dict {tci_pred = pred, tci_loc = loc})
+  = do 	{ mb_result <- lookupPred force avails [] dct
 	; case mb_result of {
 	    Nothing -> return NoInstance ;
 	    Just (dfun_id, mb_inst_tys) -> do
hunk ./compiler/typecheck/Inst.lhs 890
     }}}}
 
 ---------------
+
+anyM' :: (Monad m) => [m Bool] -> m Bool
+anyM' [] = return False
+anyM' (x:xs) =
+  do val <- x
+     if val then return True
+            else anyM' xs
+
+allM' :: (Monad m) => [m Bool] -> m Bool
+allM' [] = return True
+allM' (x:xs) =
+  do val <- x
+     if val then allM' xs
+            else return False
+
 applyContextConstraints :: Bool ->
                            Inst -> 
hunk ./compiler/typecheck/Inst.lhs 907
-                           (Inst -> TcM Bool) -> 
+                           [Inst] ->
+                           [Inst] ->
                            (InstEnv, InstEnv) -> 
                            [Type] -> 
                            ([(Instance,[Either TyVar Type])], [Instance]) -> 
hunk ./compiler/typecheck/Inst.lhs 913
                            IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
-applyContextConstraints _ _ _ _ _ x@([],_) = return x
-applyContextConstraints force inst availP ies tys (ms,us) = 
+applyContextConstraints _ _ _ _ _ _ x@([],_) = return x
+applyContextConstraints force inst avails stack ies tys (ms,us) = 
   do ms' <- filterM matchesContext ms
hunk ./compiler/typecheck/Inst.lhs 916
-     traceTc (text "MATT: applyContextCosntraints" <+> 
+     traceTc (text "MATT: applyContextConstraints" <+> 
          vcat [text "tys" <+> ppr tys,
                text "pred" <+> ppr inst,
                text "matches" <+> ppr ms,
hunk ./compiler/typecheck/Inst.lhs 926
      return (bestInstMatches ms', us)
   where
     matchesContext (match_inst, match_tvs) = 
-      do (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
-         bools <- mapM matchesPredInst predInsts
-         return $ and bools
+      do traceTc (text "MATT: matchesContext" <+>
+            vcat [text "tys" <+> ppr tys
+                 ,text "match" <+> ppr match_inst
+                 ,text "theta'" <+> ppr theta'
+                 ])
+         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
+         allM' $ map matchesPredInst predInsts
+
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
             (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
hunk ./compiler/typecheck/Inst.lhs 939
             theta' = map (substPred subst) theta
 
+            matchesPredInst :: Inst -> TcM Bool
             matchesPredInst predInst =
hunk ./compiler/typecheck/Inst.lhs 941
-              do res <- lookupPred force availP predInst
-                 return $ isJust res
+              do traceTc (text "MATT: matchesPredInst" <+>
+                    vcat [text "inst" <+> ppr inst
+                         ,text "pred" <+> ppr predInst
+                         ])
+
+                 allM' [ liftM not $ isAvail stack predInst
+                      , anyM' [ isAvail avails predInst
+                             , liftM isJust $ lookupPred force avails (inst:stack) predInst
+                             ]
+                      ]
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
hunk ./compiler/typecheck/Inst.lhs 979
     ; return (GenInst dicts (L src_loc $ HsWrap co_fn dfun))
     }}
 
-lookupInstResultAvailP :: (Inst -> TcM Bool) -> LookupInstResult -> TcM Bool
-lookupInstResultAvailP availP (GenInst dicts _) =
-  do avails <- mapM availP dicts
+
+isAvail :: [Inst] -> Inst -> TcM Bool
+isAvail avails inst 
+  = do traceTc (text "MATT: isAvail" <+> 
+          vcat [text "inst" <+> (ppr inst)
+               ,text "avails" <+> ppr avails
+               ])
+       let res = find (==inst) avails
+       case res of 
+            Just _ -> 
+              do traceTc (text "MATT: isAvail: YES" <+> (ppr inst))
+                 return True
+            Nothing -> 
+              do traceTc (text "MATT: isAvail: NO" <+> (ppr inst))
+                 return False
+
+
+lookupInstResultAvailP :: [Inst] -> LookupInstResult -> TcM Bool
+lookupInstResultAvailP avails (GenInst dicts _) =
+  do avails <- mapM (isAvail avails) dicts
      return $ and avails
 
hunk ./compiler/typecheck/Inst.lhs 1001
-instMatchAvailP :: (Inst -> TcM Bool) -> 
+instMatchAvailP :: [Inst] ->
                    Inst -> 
                    (Instance, [Either TyVar TcType]) -> 
                    IOEnv (Env TcGblEnv TcLclEnv) Bool
hunk ./compiler/typecheck/Inst.lhs 1005
-instMatchAvailP availP inst (ispec, inst_tys) =
+instMatchAvailP avails inst (ispec, inst_tys) =
   do match' <- matchInst inst (is_dfun ispec, inst_tys)
hunk ./compiler/typecheck/Inst.lhs 1007
-     lookupInstResultAvailP availP match'
+     lookupInstResultAvailP avails match'
      
 bestInstMatches :: [(Instance, [Either TyVar Type])] -> [(Instance, [Either TyVar Type])]
 bestInstMatches [] = []
hunk ./compiler/typecheck/Inst.lhs 1088
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
-checkAvail availP inst (insts,unifs) = 
-  do insts' <- filterM (instMatchAvailP availP inst) insts
+checkAvail avails inst (insts,unifs) = 
+  do insts' <- filterM (instMatchAvailP avails inst) insts
      return (insts', unifs)
 
 tcEqInstMatch (i1, _) (i2, _) 
hunk ./compiler/typecheck/Inst.lhs 1147
   | otherwise     = a:(removeDuplicates as)
   where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
 
-lookupPred :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
+lookupPred :: Bool -> [Inst] -> [Inst] -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
hunk ./compiler/typecheck/Inst.lhs 1149
-lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys)})
+lookupPred force avails stack inst@(Dict {tci_pred = pred@(ClassP clas tys)})
   = do	{ ; eps     <- getEps
 	; tcg_env <- getGblEnv
 	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
hunk ./compiler/typecheck/Inst.lhs 1162
       True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
       False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
   ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
-	; constrained <- applyContextConstraints force inst availP inst_envs tys insts 
+	; constrained <- applyContextConstraints force inst avails stack inst_envs tys insts 
   ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
hunk ./compiler/typecheck/Inst.lhs 1164
-  ; avail_insts <- checkAvail availP inst insts
+  ; avail_insts <- checkAvail avails inst insts
   ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
   ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
   ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
hunk ./compiler/typecheck/Inst.lhs 1220
 			; return Nothing }
 	}}
 
-lookupPred _ _ (Dict {tci_pred = (IParam {})}) = return Nothing	-- Implicit parameters
-lookupPred _ _ (Dict {tci_pred = (EqPred {})}) = panic "lookupPred EqPred"
+lookupPred _ _ _ (Dict {tci_pred = (IParam {})}) = return Nothing	-- Implicit parameters
+lookupPred _ _ _ (Dict {tci_pred = (EqPred {})}) = panic "lookupPred EqPred"
 
 record_dfun_usage :: Id -> TcRn ()
 record_dfun_usage dfun_id 
hunk ./compiler/typecheck/TcSimplify.lhs 1682
 	| otherwise
 	= do { w' <- zonkInst w  -- So that (3::Int) does not generate a call
 				 -- to fromInteger; this looks fragile to me
-	     ; lookup_result <- lookupSimpleInst False (\_ -> return False) w'
+	     ; lookup_result <- lookupSimpleInst False [] w'
 	     ; case lookup_result of
 		 NoInstance      -> go (w:irreds) binds ws
 		 GenInst ws' rhs -> go irreds binds' (ws' ++ ws)
hunk ./compiler/typecheck/TcSimplify.lhs 2231
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst force (isAvail avails) wanted
+      = do { res <- lookupSimpleInst force (availsInsts avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
hunk ./compiler/typecheck/TcSimplify.lhs 2330
                ,text "avails" <+> ppr avails
                ])
        traceTc (text "MATT: elemAvails" <+> (ppr $ elemAvails inst avails))
-       let res = findAvail avails inst
+       let insts = availsInsts avails
+       let res = find (==inst) insts
        case res of 
             Just how -> 
               do traceTc (text "MATT: isAvail how" <+> (ppr how))
hunk ./compiler/typecheck/TcSimplify.lhs 2344
 ---------------------------------------------
 reduceInst :: Bool -> RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
 reduceInst force _ avails other_inst
-  = do	{ result <- lookupSimpleInst force (isAvail avails) other_inst
+  = do	{ result <- lookupSimpleInst force (availsInsts avails) other_inst
 	; return (avails, result) }
 \end{code}
 
}
[Context Constraints
matt@softmechanics.net**20100406202530
 Ignore-this: 7a71aea7a67987e659d122a6b42c4717
] {
hunk ./compiler/typecheck/Inst.lhs 915
                            IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
 applyContextConstraints _ _ _ _ _ _ x@([],_) = return x
 applyContextConstraints force inst avails stack ies tys (ms,us) = 
-  do ms' <- filterM matchesContext ms
+  do maybes <- mapM matchesContext ms
+     let ms' = mapMaybe id maybes
      traceTc (text "MATT: applyContextConstraints" <+> 
          vcat [text "tys" <+> ppr tys,
                text "pred" <+> ppr inst,
hunk ./compiler/typecheck/Inst.lhs 924
                text "constrained" <+> ppr ms',
                text "unifs" <+> ppr us])
   
-     return (bestInstMatches ms', us)
+     return (ms', us)
   where
hunk ./compiler/typecheck/Inst.lhs 926
-    matchesContext (match_inst, match_tvs) = 
-      do traceTc (text "MATT: matchesContext" <+>
-            vcat [text "tys" <+> ppr tys
+    pop [] = []
+    pop (_:x) = x
+
+    matchesContext :: (Instance, [Either TyVar Type]) -> TcM (Maybe (Instance, [Either TyVar Type]))
+    matchesContext m@(match_inst, match_tvs) 
+      | not matches_tys = 
+        do {
+          ;traceTc (text "MATT: types don't merge" <+> 
+              vcat [text "tys" <+> ppr tys
+                   ,text "matchTys" <+> ppr (instanceTypes match_inst)
+                   ])
+          ;return Nothing
+        }
+      | otherwise = 
+        do {
+        ;(GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst, match_tvs)
+        ;traceTc (text "MATT: matchesContext" <+>
+            vcat [text "inst" <+> ppr inst
+                 ,text "stack" <+> ppr stack
+                 ,text "tys" <+> ppr tys
+                 ,text "matchTys" <+> ppr (instanceTypes match_inst)
+                 ,text "matchTvs" <+> ppr match_tvs
+                 -- ,text "instanceTyVars" <+> ppr (instanceTyVars inst)
+                 ,text "match instanceTyVars" <+> ppr (instanceTyVars match_inst)
+                 ,text "merged tys" <+> ppr merged_tys
                  ,text "match" <+> ppr match_inst
hunk ./compiler/typecheck/Inst.lhs 952
-                 ,text "theta'" <+> ppr theta'
+                 ,text "predInsts" <+> ppr predInsts
+                 ,text "theta tyVars" <+> ppr (tyVarsPreds theta)
                  ])
hunk ./compiler/typecheck/Inst.lhs 955
-         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
-         allM' $ map matchesPredInst predInsts
+        ; if improved tys match_inst
+              then do -- merging gave us more specific tys, so start over with these.
+                   -- reuse (instLoc inst) because I don't know how to make one for
+                   -- this new pred.  I believe it's the location of the use, not the def.
+                   merged_pred <- newDict (instLoc inst) $ ClassP (instanceClass match_inst) $ fromJust merged_tys 
+                   traceTc (text "MATT: types improved; restarting" <+> ppr merged_pred)
+
+                   looped <- isAvail stack merged_pred
+                   if looped then return Nothing
+                             else do r <- lookupPred force avails (merged_pred:pop stack) merged_pred
+                                     return $ case r of 
+                                                   Nothing -> Nothing
+                                                   Just (_, tys_tvs) -> Just (match_inst, tys_tvs)
+             else do -- let tvMap = map (\x->(x,TyVarTy x)) $ mapMaybe (either Just (\x -> Nothing)) match_tvs
+                     r <- matchPredLoop [] [] predInsts
+                     return $ if isJust r 
+                                 then Just m
+                                 else Nothing
+
+        }
 
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
hunk ./compiler/typecheck/Inst.lhs 978
-            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
-            theta' = map (substPred subst) theta
 
hunk ./compiler/typecheck/Inst.lhs 979
-            matchesPredInst :: Inst -> TcM Bool
+            matchPredLoop :: [(TyVar,Type)] -> [Inst] -> [Inst] -> TcM (Maybe [(TyVar,Type)])
+            matchPredLoop tvMap [] []  = return $ Just tvMap
+            matchPredLoop _ faileds [] 
+              = do traceTc (text "MATT: matchPredLoop FAILED" <+> ppr faileds)
+                   return Nothing
+            matchPredLoop tvMap failedPreds (pred:preds) 
+              = do traceTc (text "MATT: matchPredLoop" <+>
+                      vcat [text "tvMap" <+> ppr tvMap
+                           ,text "pred" <+> ppr pred
+                           ,text "faileds" <+> ppr failedPreds
+                           ])
+                   r <- matchesPredInst pred
+                   
+                   -- returns a typemap if matching improved types
+                   case r of
+                        -- succeeded, but no tyVars were resolved
+                        Just [] -> matchPredLoop tvMap failedPreds preds
+
+                        -- succeeded with tyVars resolved!
+                        Just mapUpdate -> do let preds' = (mapTyVarsToTypesInsts mapUpdate $ preds ++ failedPreds)
+                                             traceTc (text "MATT: matching pred improved tyVars" <+>
+                                                vcat [text "pred" <+> ppr pred
+                                                     ,text "improved" <+> ppr mapUpdate
+                                                     ,text "todo" <+> ppr preds
+                                                     ,text "faileds" <+> ppr failedPreds
+                                                     ,text "todo'" <+> ppr preds'
+                                                     ])
+                                             -- retry faileds with improvement
+                                             matchPredLoop tvMap [] preds'
+                        Nothing -> matchPredLoop tvMap (pred:failedPreds) preds
+
+            mkThetaTyMap :: Inst -> PredType -> (Inst,[(Type,Type)])
+            mkThetaTyMap inst pred = (inst, zip (predTys pred) (dictTys inst))
+            predTys (ClassP _ tys) = tys
+            dictTys (Dict {tci_pred = pred}) = predTys pred
+
+            matches_tys | isJust $ merged_tys = True
+                        | otherwise = False
+            improved tys inst' = 
+              case merge_tys tys inst' of
+                   Just tys' -> (countTyVars tys') < (countTyVars tys)
+                   Nothing   -> False
+
+            merge_tys tys inst' = mergeTys tys (instanceTypes inst')
+            merged_tys = merge_tys tys match_inst
+
+            -- replace ty vars in match with ty var parameters (which we may have some preds for)
+            match_tvs' = map lookupTyVar match_tvs
+              where tvMap = mkTvMap $ zip (instanceTypes match_inst) tys
+                    lookupTyVar (Left tv) = 
+                        case tvLookupByName tv tvMap of
+                             Just (TyVarTy tv') -> Left tv'
+                             Just ty -> Right ty  -- is this right? maybe just keep tv
+                             Nothing -> Left tv
+
+                    lookupTyVar (Right ty@(TyVarTy tv)) = Right $ fromMaybe ty (tvLookupByName tv tvMap)
+                    lookupTyVar (Right ty) = Right ty
+
+            -- some pred (fundep) resolved a var!  update any references to that var elsewhere in the theta
+            improve_theta :: [(TyVar,Type)] -> [PredType] 
+            improve_theta tvMap = mapTyVarsToTypesPreds tvMap theta
+
+            mkTvMap :: [(Type,Type)] -> [(TyVar,Type)]
+            mkTvMap = mapMaybe toTvMapElem
+            toTvMapElem (TyVarTy tv, ty) = Just (tv,ty)
+            toTvMapElem _ = Nothing
+
+
+            -- TODO: if one pred improves the types (fundeps), then apply that improvement
+            -- to all preds
+            matchesPredInst :: Inst -> TcM (Maybe [(TyVar,Type)])
             matchesPredInst predInst =
               do traceTc (text "MATT: matchesPredInst" <+>
                     vcat [text "inst" <+> ppr inst
hunk ./compiler/typecheck/Inst.lhs 1053
+                         ,text "match_tvs" <+> ppr match_tvs
+                         ,text "tys" <+> ppr tys
                          ,text "pred" <+> ppr predInst
hunk ./compiler/typecheck/Inst.lhs 1056
+                         ,text "predTys" <+> ppr (dictTys predInst)
                          ])
 
hunk ./compiler/typecheck/Inst.lhs 1059
-                 allM' [ liftM not $ isAvail stack predInst
-                      , anyM' [ isAvail avails predInst
-                             , liftM isJust $ lookupPred force avails (inst:stack) predInst
-                             ]
-                      ]
+                 avail <- isAvail avails predInst
+                 if avail
+                    then return $ Just []
+                    else do looped <- isAvail stack predInst
+                            if looped 
+                               then return Nothing
+                               else lookup
+              where lookup
+                      = do {
+                        ; choices <- lookupPredChoices force avails (inst:stack) predInst
+                        ; let choices_params = (map (instanceTypes.fst) choices)
+                        ; let pred_tys = dictTys predInst
+                        ; let merged_params = mapMaybe (mergeTys pred_tys) choices_params
+                        ; let improved_params = filter (\p -> (countTyVars p) < (countTyVars pred_tys)) merged_params
+                        ; let tvMaps = map (mkTvMap . zip pred_tys) improved_params
+                        ; let improved_thetas = map improve_theta tvMaps
+                        ; traceTc (text "MATT: Lookup Choices" <+>
+                             vcat [text "inst" <+> ppr inst
+                                  ,text "match_tvs" <+> ppr match_tvs
+                                  ,text "tys" <+> ppr tys
+                                  ,text "pred" <+> ppr predInst
+                                  ,text "pred tys" <+> ppr pred_tys
+                                  ,text "choices" <+> ppr choices
+                                  ,text "choices parameterizations" <+> ppr choices_params
+                                  ,text "merged parameterizations" <+> ppr merged_params
+                                  ,text "improved parameterizations" <+> ppr improved_params
+                                  ,text "tvMaps" <+> ppr tvMaps
+                                  ,text "theta" <+> ppr theta
+                                  ,text "improved thetas" <+> ppr improved_thetas
+                                  ])
+
+                        -- TODO: what if >1 matches?  should we try them all?
+                        ; case tvMaps of 
+                               [tvMap] -> do traceTc (text "MATT: Lookup Succeeded!")
+                                             return $ Just tvMap
+                               _ -> case choices of
+                                         [_] -> return $ Just []
+                                         _ -> return Nothing
+
+--                        ; lookupResult <- lookupPred force avails (inst:stack) predInst
+--                        ; case lookupResult of 
+--                               Just (_,tys') -> do {
+--                                 ; traceTc (text "Lookup Succeeded!" <+>
+--                                      vcat [text "inst tys" <+> (ppr $ (\(Dict {tci_pred = ClassP _ tys}) -> tys) predInst)
+--                                           ,text "pred tys" <+> ppr tys
+--                                           ,text "result tys" <+> ppr tys'
+--                                           ])
+--                                 ; return $ Just []
+--                                 }
+--                               Nothing -> return Nothing
+                      }
+
+
+countTyVars :: [Type] -> Int
+countTyVars tys = 
+  sum $ map count tys
+  where count :: Type -> Int
+        count (TyVarTy _) = 1
+        count (AppTy ty1 ty2) = (count ty1) + (count ty2)
+        count (TyConApp _ tys') = countTyVars tys'
+        count (FunTy ty1 ty2) = (count ty1) + (count ty2)
+
+mergeTys :: [Type] -> [Type] -> Maybe [Type]
+mergeTys tys1 tys2 = allMaybes' $ zipWith pickTy tys1 tys2
+  where
+    allMaybes' :: [Maybe Type] -> Maybe [Type]
+    allMaybes' ts | all isJust ts = Just $ map fromJust ts
+                  | otherwise = Nothing
+    allMaybes :: Maybe Type -> Maybe [Type] -> Maybe [Type]
+    allMaybes Nothing Nothing = Nothing
+    allMaybes Nothing _ = Nothing
+    allMaybes _ Nothing = Nothing
+    allMaybe (Just t) (Just ts) = Just (t:ts)
+
+    pickTy tv@(TyVarTy _) (TyVarTy _) = Just tv
+    pickTy (TyVarTy _) ty = Just ty
+    pickTy ty (TyVarTy _) = Just ty
+    pickTy ty1 ty2 | tcEqType ty1 ty2 = Just ty1
+    pickTy (TyConApp con tys1) (TyConApp _ tys2) =
+      -- assume cons are ==
+      case mergeTys tys1 tys2 of
+           Just tys -> Just $ TyConApp con tys
+           Nothing  -> Nothing
+    pickTy _ _ = Nothing
+
+--mergeTys :: [Either TyVar TcType] -> [Either TyVar TcType] -> [Either TyVar TcType]
+--mergeTys [] [] = []
+--mergeTys ((Left _):l1) ((r@(Right _)):l2) = r:(mergeTys l1 l2)
+-- always keep tyvars from first list
+--mergeTys ((r@(Right _)):l1) ((Left _):l2) = r:(mergeTys l1 l2)
+--mergeTys (tv@(Left _):l1) ((Left _):l2) 
+--  = tv : (mergeTys l1 l2)
+--mergeTys (ty@(Right _):l1) ((Right _):l2) = ty : mergeTys l1 l2
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
hunk ./compiler/typecheck/Inst.lhs 1165
 	-- (presumably there's a functional dependency in class C)
 	-- Hence mb_inst_tys :: Either TyVar TcType 
 
-    ; let inst_tv (Left tv)  = do { tv' <- tcInstTyVar tv; return (mkTyVarTy tv') }
-	  inst_tv (Right ty) = return ty
-    ; tys <- mapM inst_tv mb_inst_tys
+--    ; let inst_tv (Left tv)  = do { tv' <- tcInstTyVar tv; return (mkTyVarTy tv') }
+--	  inst_tv (Right ty) = return ty
+--    ; tys <- mapM inst_tv mb_inst_tys
+      ; let toType (Left tv) = mkTyVarTy tv
+            toType (Right ty) = ty
+      ; let  tys = map toType mb_inst_tys
     ; let
     	(theta, _) = tcSplitPhiTy (applyTys (idType dfun_id) tys)
 	src_loc	   = instLocSpan loc
hunk ./compiler/typecheck/Inst.lhs 1260
 instanceTheta = (\(_,x,_,_) -> x) . instanceHead 
 instanceTyVars :: Instance -> [TyVar]
 instanceTyVars = (\(x,_,_,_) -> x) . instanceHead
+instanceTypes :: Instance -> [Type]
+instanceTypes = (\(_,_,_,x) -> x) . instanceHead
+instanceClass :: Instance -> Class
+instanceClass = (\(_,_,x,_) -> x) . instanceHead
 
 isMostSpecificContext :: (Instance, [Either TyVar Type])
                       -> [(Instance, [Either TyVar Type])]
hunk ./compiler/typecheck/Inst.lhs 1293
 eqVarNamesType (TyConApp c1 tys1) (TyConApp c2 tys2) = c1 == c2 && tys1 `eqVarNamesTypes` tys2
 eqVarNamesType (FunTy f1 a1) (FunTy f2 a2) = f1 `eqVarNamesType` f2 && a1 `eqVarNamesType` a2
 eqVarNamesType (ForAllTy tv1 ty1) (ForAllTy tv2 ty2) = tv1 `eqVarNamesVar` tv2 && ty1 `eqVarNamesType` ty2
+eqVarNamesType (PredTy p1) (PredTy p2) = p1 `eqVarNamesPred` p2
+eqVarNamesType _ _ = False
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
hunk ./compiler/typecheck/Inst.lhs 1309
       where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
             theta2 = instanceTheta i2
 
+mapTyVarsToTypesInsts tvMap = map (mapTyVarsToTypesInst tvMap)
+mapTyVarsToTypesInst tvMap inst@(Dict {tci_pred=pred}) = inst { tci_pred = mapTyVarsToTypesPred tvMap pred }
+
+mapTyVarsToTypesPreds tvMap = map (mapTyVarsToTypesPred tvMap) 
+mapTyVarsToTypesPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsToTypesTypes tvMap tys
+
+mapTyVarsToTypesTypes :: [(TyVar,Type)] -> [Type] -> [Type]
+mapTyVarsToTypesTypes tvMap tys = map (mapTyVarsToTypesType tvMap) tys
+
+mapTyVarsToTypesType :: [(TyVar,Type)] -> Type -> Type
+mapTyVarsToTypesType tvMap (TyVarTy tv) = mapTyVarType tvMap tv
+mapTyVarsToTypesType tvMap (AppTy ty1 ty2) = AppTy (mapTyVarsToTypesType tvMap ty1) (mapTyVarsToTypesType tvMap ty2)
+mapTyVarsToTypesType tvMap (TyConApp tc tys) = TyConApp tc $ mapTyVarsToTypesTypes tvMap tys
+mapTyVarsToTypesType tvMap (FunTy ty1 ty2) = FunTy (mapTyVarsToTypesType tvMap ty1) (mapTyVarsToTypesType tvMap ty2)
+--mapTyVarsToTypesType tvMap (ForAllTy tv ty) = ForAllTy (mapTyVar tvMap tv) (mapTyVarsToTypesType tvMap ty)
+mapTyVarsToTypesType tvMap (PredTy pred) = PredTy $ mapTyVarsToTypesPred tvMap pred
+
+mapTyVarType :: [(TyVar, Type)] -> TyVar -> Type
+mapTyVarType tvMap tv = fromMaybe (TyVarTy tv) $ tvLookupByName tv tvMap 
+
+updateTvMap :: [(TyVar, a)] -> [(TyVar, a)] -> [(TyVar, a)]
+updateTvMap tvMap updates
+  = foldr update tvMap updates
+  where update up@(v1,val) (e@(v2,_):elems) 
+               | v1 `eqVarNamesVar` v2 = (v1,val):elems
+               | otherwise = e:(update up elems)
+
+
 mapTyVarsPreds tvMap = map (mapTyVarsPred tvMap) 
 mapTyVarsPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsTypes tvMap tys
 
hunk ./compiler/typecheck/Inst.lhs 1350
 mapTyVarsType tvMap (ForAllTy tv ty) = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
 mapTyVarsType tvMap (PredTy pred) = PredTy $ mapTyVarsPred tvMap pred
 
+tyVarsTypes :: [Type] -> [TyVar]
+tyVarsTypes tys = tvUnique $ foldr (++) [] $ map tyVarsType tys
+
+tvUnique :: [TyVar] -> [TyVar]
+tvUnique [] = []
+tvUnique (v:vs) | isJust $ find (eqVarNamesVar v) vs = tvUnique vs
+              | otherwise = v:(tvUnique vs)
+
+tyVarsType :: Type -> [TyVar]
+tyVarsType (TyVarTy tv) = [tv]
+tyVarsType (AppTy ty1 ty2) = tyVarsTypes [ty1,ty2]
+tyVarsType (TyConApp _ tys) = tyVarsTypes tys
+tyVarsType (FunTy ty1 ty2) = tyVarsTypes [ty1,ty2]
+tyVarsType (PredTy pred) = tyVarsPred pred
+
+tyVarsPreds preds = tyVarsTypes $ foldr (++) [] $ map (\(ClassP _ tys) -> tys) preds
+
+tyVarsPred :: PredType -> [TyVar]
+tyVarsPred (ClassP _ tys) = tyVarsTypes tys
+
+
+tvLookupByName :: TyVar -> [(TyVar, a)] -> Maybe a
+tvLookupByName tv1 tvMap = find (\(tv2,_) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+
+tyVarsToTypes :: [(TyVar, Type)] -> Type -> Type
+tyVarsToTypes tvMap ty@(TyVarTy tv)
+  = case tvLookupByName tv tvMap of
+         Nothing  -> ty
+         Just ty' -> ty'
+tyVarsToTypes tvMap (AppTy ty1 ty2) = AppTy (tyVarsToTypes tvMap ty1) (tyVarsToTypes tvMap ty2)
+tyVarsToTypes tvMap (TyConApp tc tys) = TyConApp tc $ map (tyVarsToTypes tvMap) tys
+tyVarsToTypes tvMap (FunTy ty1 ty2) = FunTy (tyVarsToTypes tvMap ty1) (tyVarsToTypes tvMap ty2)
+tyVarsToTypes tvMap (ForAllTy tv ty) = undefined
+tyVarsToTypes tvMap (PredTy pred) = PredTy $ tyVarsToTypesPred tvMap pred
+
+tyVarsToTypesPred :: [(TyVar, Type)] -> PredType -> PredType
+tyVarsToTypesPred tvMap (ClassP cls tys) = ClassP cls $ map (tyVarsToTypes tvMap) tys
+
 mapTyVar :: [(TyVar, TyVar)] -> TyVar -> TyVar
hunk ./compiler/typecheck/Inst.lhs 1389
-mapTyVar tvMap tv 
-  = case lookup' tv of
-    Just tv' -> tv'
-    Nothing  -> tv
-  where lookup' tv1 = find (\(tv2,_) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+mapTyVar tvMap tv = fromMaybe tv $ tvLookupByName tv tvMap 
 
 mkInstTypeMap :: Instance -> Instance -> Maybe [(TyVar, TyVar)]
 mkInstTypeMap i1 i2
hunk ./compiler/typecheck/Inst.lhs 1419
   | otherwise     = a:(removeDuplicates as)
   where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
 
+-- lookupUnif :: Instance -> [(Instance, [Either TyVar TcType])]
+lookupUnif inst_envs unif = 
+  lookupInstEnv inst_envs cls tys
+  -- return found
+  where tys = instanceTypes unif
+        cls = instanceClass unif
+        -- ([found],[]) = lookupInstEnv inst_envs cls tys
+
+lookupPredChoices :: Bool -> [Inst] -> [Inst] -> Inst -> TcM [(Instance, [Either TyVar TcType])]
+lookupPredChoices force avails stack inst@(Dict {tci_pred = pred@(ClassP clas tys)})
+  = do { ; eps     <- getEps
+        ; tcg_env <- getGblEnv
+        ; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
+        ; let insts = lookupInstEnv inst_envs clas tys 
+        ; traceTc (text "MATT: STACK" <+> ppr stack)
+        ; let inst_matches = fst insts
+        ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
+
+        -- TODO: check for ContextConstraints flag
+        case force of
+            True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
+            False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
+        ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
+        ; constrained <- applyContextConstraints force inst avails stack inst_envs tys insts 
+        ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
+        ; avail_insts <- checkAvail avails inst insts
+        ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
+        ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
+        ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
+        ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
+        ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
+        ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
+        ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
+        ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
+        ; traceTc (text "MATT: BEST OF BOTH WORLDS" <+> (ppr best_both))
+        ; let (best_matches, best_unifs) = best_both
+        ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
+        ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
+
+        -- TODO: if adopting a unif, make sure the type corresponding to each typevar we're
+        -- looking for matches the known contexts.  That should help constrain multiple
+        -- unifs as well
+        ; let all_unifs = map (lookupUnif inst_envs) best_unifs
+        ; traceTc (text "MATT: ALL UNIFS" <+> (ppr all_unifs))
+        ; let unif_matches = removeDuplicates $ foldr (++) [] $ map fst all_unifs 
+        ; traceTc (text "MATT: UNIF MATCHES" <+> (ppr unif_matches))
+
+        -- TODO: to constrain unifs, merge tys with instance tys (if instance has a type for a tyvar in tys,
+        -- use it.  if tys has a type for a tyvar in instance, use that
+        ; constrained_unifs <- applyContextConstraints force inst avails stack inst_envs tys (unif_matches, [])
+        ; traceTc (text "MATT: CONSTRAINED UNIFS" <+> (ppr constrained_unifs))
+        ; let best_unifs = bestInstMatches unif_matches
+        ; traceTc (text "MATT: BEST UNIFS" <+> (ppr best_unifs))
+        ; let best_unifs_possible = filter (flip isMostSpecificContext unif_matches) best_unifs
+        ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_unifs_possible))
+
+
+
+        ; let final' = if null best_matches 
+                               then if force
+                                       then ((best_unifs)::([(Instance, [Either TyVar Type])]))
+                                       else ((best_unifs_possible)::([(Instance, [Either TyVar Type])]))
+                               else if force 
+                                       -- time to decide. pick the best match(es).
+                                       then best_matches
+                                       -- still have time to see if we get a better match.
+                                       -- if there is no better match, can decide now
+                                       else best_possible
+        ; case force of
+            True -> traceTc (text "MATT: LOOKUP DONE (FORCE)" <+> 
+                        vcat [text "pred" <+> ppr pred,
+                              text "final" <+> ppr final'])
+            False -> traceTc (text "MATT: LOOKUP DONE" <+> 
+                        vcat [text "pred" <+> ppr pred,
+                              text "final" <+> ppr final'])
+        ; traceTc (text "MATT: DONE: " <+> (ppr final'))
+        ; return final'
+      }
+
 lookupPred :: Bool -> [Inst] -> [Inst] -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
 lookupPred force avails stack inst@(Dict {tci_pred = pred@(ClassP clas tys)})
hunk ./compiler/typecheck/Inst.lhs 1501
-  = do	{ ; eps     <- getEps
-	; tcg_env <- getGblEnv
-	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
-	; let insts = lookupInstEnv inst_envs clas tys 
-  ; let inst_matches = fst insts
-  ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
-
-	-- TODO: check for ContextConstraints flag
-  case force of
-      True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
-      False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
-  ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
-	; constrained <- applyContextConstraints force inst avails stack inst_envs tys insts 
-  ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
-  ; avail_insts <- checkAvail avails inst insts
-  ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
-  ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
-  ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
-  ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
-  ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
-  ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
-  ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
-  ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
-  ; traceTc (text "MATT: BEST OF BOTH WORLDS" <+> (ppr best_both))
-  ; let (best_matches, _) = best_both
-  ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
-  ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
+  = do	{ 
   ; enabled <- contextConstraintsEnabled
hunk ./compiler/typecheck/Inst.lhs 1503
-  ; let final = case enabled of
-                      False -> insts
-                      True -> case force of
-                                  -- time to decide. pick the best match(es).
-                                  True -> (fst best_both, [])
-
-                                  -- still have time to see if we get a better match.
-                                  -- if there is no better match, can decide now
-                                  False -> (best_possible, []) 
-
-  ; case force of
-      True -> traceTc (text "MATT: LOOKUP DONE (FORCE)" <+> 
-                  vcat [text "pred" <+> ppr pred,
-                        text "final" <+> ppr final])
-      False -> traceTc (text "MATT: LOOKUP DONE" <+> 
-                  vcat [text "pred" <+> ppr pred,
-                        text "final" <+> ppr final])
-  ; traceTc (text "MATT: DONE: " <+> (ppr final))
+  ; final <- if not enabled 
+      then do {
+        ; eps     <- getEps
+        ; tcg_env <- getGblEnv
+        ; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
+        ; return $ lookupInstEnv inst_envs clas tys
+      }
+      else do {
+        ; choices <- lookupPredChoices force avails stack inst
+        ; return (choices, [])
+      }
 	; case final of {
 	    ([(ispec, inst_tys)], []) 
 		-> do	{ let dfun_id = is_dfun ispec
hunk ./compiler/typecheck/Inst.lhs 1522
 				         text "witness" <+> ppr dfun_id
 					 <+> ppr (idType dfun_id) ])
 				-- Record that this dfun is needed
-			; record_dfun_usage dfun_id
+        -- only if at the top level.  otherwise, we just checking a dependency.
+        -- we may not need it, i.e. not all deps met, better match is found
+			; if (null stack) then record_dfun_usage dfun_id
+          else return ()
 			; return (Just (dfun_id, inst_tys)) } ;
 
      	    (matches, unifs)
}
[Better Handling of Functional Dependencies in Contexts
matt@softmechanics.net**20100407185959
 Ignore-this: f2dfb4c32f7e5e936b07e5419c199204
 1) Need to only allow a predicate to "resolve" a type variable (replace it with
    a concrete type) if the pred has a functional dependency, and no dependencies
    are type variables.  Still todo, in the meantime, make sure we have at least
    one real type (no check for fun dep).  I.e. don't resolve any variable if we
    don't know any types.
 2) If applyContextConstraints resolves any variables, update the type/variable
    parameters for the instance use under consideration.
 
] {
hunk ./compiler/typecheck/Inst.lhs 881
     	(theta, _) = tcSplitPhiTy (applyTys (idType dfun_id) tys)
 	src_loc	   = instLocSpan loc
 	dfun	   = HsVar dfun_id
+    ; traceTc (text "MATT: lookupSimpleInst result theta" <+> ppr theta)
     ; if null theta then
         return (GenInst [] (L src_loc $ HsWrap (mkWpTyApps tys) dfun))
       else do
hunk ./compiler/typecheck/Inst.lhs 969
                                      return $ case r of 
                                                    Nothing -> Nothing
                                                    Just (_, tys_tvs) -> Just (match_inst, tys_tvs)
-             else do -- let tvMap = map (\x->(x,TyVarTy x)) $ mapMaybe (either Just (\x -> Nothing)) match_tvs
-                     r <- matchPredLoop [] [] predInsts
-                     return $ if isJust r 
-                                 then Just m
-                                 else Nothing
-
+             else do r <- matchPredLoop [] [] predInsts
+                     case r of
+                          Nothing -> return Nothing
+                          Just [] -> return $ Just m
+                          Just tvMap -> do { let match_tvs' = updateMatchTypes tvMap
+                                           ; traceTc (text "MATT: fixing types" <+>
+                                                vcat [ text "tvMap" <+> ppr tvMap
+                                                     , text "match_tvs" <+> ppr match_tvs
+                                                     , text "match_tvs'" <+> ppr match_tvs'
+                                                     ])
+                                           ; return $ Just (match_inst, match_tvs')
+                                           }
         }
hunk ./compiler/typecheck/Inst.lhs 982
-
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
 
hunk ./compiler/typecheck/Inst.lhs 985
+            updateMatchTypes :: [(TyVar,Type)] -> [Either TyVar Type]
+            updateMatchTypes tvMap = map update match_tvs
+              where update (Left tv) = Right $ mapTyVarType tvMap tv
+                        -- Left tv
+                    update (Right ty) = Right $ mapTyVarsToTypesType tvMap ty
+
             matchPredLoop :: [(TyVar,Type)] -> [Inst] -> [Inst] -> TcM (Maybe [(TyVar,Type)])
             matchPredLoop tvMap [] []  = return $ Just tvMap
             matchPredLoop _ faileds [] 
hunk ./compiler/typecheck/Inst.lhs 1019
                                                      ,text "todo'" <+> ppr preds'
                                                      ])
                                              -- retry faileds with improvement
-                                             matchPredLoop tvMap [] preds'
+                                             -- TODO: is ++ right?
+                                             matchPredLoop (tvMap ++ mapUpdate) [] preds'
                         Nothing -> matchPredLoop tvMap (pred:failedPreds) preds
 
             mkThetaTyMap :: Inst -> PredType -> (Inst,[(Type,Type)])
hunk ./compiler/typecheck/Inst.lhs 1088
                         ; let improved_params = filter (\p -> (countTyVars p) < (countTyVars pred_tys)) merged_params
                         ; let tvMaps = map (mkTvMap . zip pred_tys) improved_params
                         ; let improved_thetas = map improve_theta tvMaps
+
+                        -- TODO: don't improve type variables unless fun dep, we have all the dependent types
+                        -- FIXME: hack to simulate fundep restriction: must have at least one real type
+                        ; let canImprove = 0 < countTyVars pred_tys
                         ; traceTc (text "MATT: Lookup Choices" <+>
                              vcat [text "inst" <+> ppr inst
                                   ,text "match_tvs" <+> ppr match_tvs
hunk ./compiler/typecheck/Inst.lhs 1105
                                   ,text "tvMaps" <+> ppr tvMaps
                                   ,text "theta" <+> ppr theta
                                   ,text "improved thetas" <+> ppr improved_thetas
+                                  ,text "can improve" <+> ppr canImprove
                                   ])
 
                         -- TODO: what if >1 matches?  should we try them all?
hunk ./compiler/typecheck/Inst.lhs 1109
-                        ; case tvMaps of 
-                               [tvMap] -> do traceTc (text "MATT: Lookup Succeeded!")
-                                             return $ Just tvMap
-                               _ -> case choices of
-                                         [_] -> return $ Just []
-                                         _ -> return Nothing
 
hunk ./compiler/typecheck/Inst.lhs 1110
---                        ; lookupResult <- lookupPred force avails (inst:stack) predInst
---                        ; case lookupResult of 
---                               Just (_,tys') -> do {
---                                 ; traceTc (text "Lookup Succeeded!" <+>
---                                      vcat [text "inst tys" <+> (ppr $ (\(Dict {tci_pred = ClassP _ tys}) -> tys) predInst)
---                                           ,text "pred tys" <+> ppr tys
---                                           ,text "result tys" <+> ppr tys'
---                                           ])
---                                 ; return $ Just []
---                                 }
---                               Nothing -> return Nothing
+                        ; if canImprove 
+                             then case tvMaps of 
+                                       [tvMap] -> do traceTc (text "MATT: Lookup Succeeded!")
+                                                     return $ Just tvMap
+                                       _ -> case choices of
+                                                 [_] -> return $ Just []
+                                                 _ -> return Nothing
+                             else case choices of
+                                       [_] -> return $ Just []
+                                       _ -> return Nothing
+
                       }
 
 
hunk ./compiler/typecheck/Inst.lhs 1314
   do insts' <- filterM (instMatchAvailP avails inst) insts
      return (insts', unifs)
 
-tcEqInstMatch (i1, _) (i2, _) 
-  = case mkInstTypeMap i1 i2 of
-    Nothing -> False
-    (Just tvMap) -> tcEqTheta theta1 theta2
-      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-            theta2 = instanceTheta i2
+-- TODO: make sure TYPES are equal too!
+tcEqInstMatch (i1, t1) (i2, t2) 
+  | tcEqInstTypes t1 t2 && tcEqTypes (instanceTypes i1) (instanceTypes i2)
+    = case mkInstTypeMap i1 i2 of
+      Nothing -> False
+      (Just tvMap) -> tcEqTheta theta1 theta2
+        where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+              theta2 = instanceTheta i2
+  | otherwise
+    = False
 
 mapTyVarsToTypesInsts tvMap = map (mapTyVarsToTypesInst tvMap)
 mapTyVarsToTypesInst tvMap inst@(Dict {tci_pred=pred}) = inst { tci_pred = mapTyVarsToTypesPred tvMap pred }
hunk ./compiler/typecheck/Inst.lhs 1486
         -- use it.  if tys has a type for a tyvar in instance, use that
         ; constrained_unifs <- applyContextConstraints force inst avails stack inst_envs tys (unif_matches, [])
         ; traceTc (text "MATT: CONSTRAINED UNIFS" <+> (ppr constrained_unifs))
-        ; let best_unifs = bestInstMatches unif_matches
+        ; let best_unifs = bestInstMatches $ fst constrained_unifs
         ; traceTc (text "MATT: BEST UNIFS" <+> (ppr best_unifs))
         ; let best_unifs_possible = filter (flip isMostSpecificContext unif_matches) best_unifs
         ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_unifs_possible))
hunk ./compiler/typecheck/Inst.lhs 1491
 
+        ; let allTypes = 0 == countTyVars tys
+        ; let someTypes = 0 < countTyVars tys
+        ; let allVars = length tys == countTyVars tys
+
+        -- if there are better potential matches, delay deciding as long as possible.
+        -- if there are no type vars in the lookupPred, waiting won't help, so decide now
+        -- if force, decide now
+        ; let decide = allTypes || force
 
 
hunk ./compiler/typecheck/Inst.lhs 1501
-        ; let final' = if null best_matches 
-                               then if force
+        ; let final' = if (null best_matches) && someTypes
+                               then if decide
                                        then ((best_unifs)::([(Instance, [Either TyVar Type])]))
                                        else ((best_unifs_possible)::([(Instance, [Either TyVar Type])]))
hunk ./compiler/typecheck/Inst.lhs 1505
-                               else if force 
+                               else if decide 
                                        -- time to decide. pick the best match(es).
                                        then best_matches
                                        -- still have time to see if we get a better match.
hunk ./compiler/typecheck/TcSimplify.lhs 2231
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst force (availsInsts avails) wanted
+      = do { traceTc (text "MATT: calling lookupSimpleInst" <+> ppr avails)
+        ;res <- lookupSimpleInst force (availsInsts avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
}

Context:

[UNDO: slight improvement to scavenging ...
Simon Marlow <marlowsd@gmail.com>**20100319153413
 Ignore-this: f0ab581c07361f7b57eae02dd6ec893c
 
 Accidnetally pushed this patch which, while it validates, isn't
 correct.
 
 rolling back:
 
 Fri Mar 19 11:21:27 GMT 2010  Simon Marlow <marlowsd@gmail.com>
   * slight improvement to scavenging of update frames when a collision has occurred
 
     M ./rts/sm/Scav.c -19 +15
] 
[slight improvement to scavenging of update frames when a collision has occurred
Simon Marlow <marlowsd@gmail.com>**20100319112127
 Ignore-this: 6de2bb9614978975f17764a0f259d9bf
] 
[Don't install the utf8-string package
Ian Lynagh <igloo@earth.li>**20100317212709] 
[Don't use -Bsymbolic when linking the RTS
Ian Lynagh <igloo@earth.li>**20100316233357
 This makes the RTS hooks work when doing dynamic linking
] 
[Fix Trac #3920: Template Haskell kinds
simonpj@microsoft.com**20100317123519
 Ignore-this: 426cac7920446e04f3cc30bd1d9f76e2
 
 Fix two places where we were doing foldl instead of foldr
 after decomposing a Kind.  Strange that the same bug appears
 in two quite different places!
] 
[copy_tag_nolock(): fix write ordering and add a write_barrier()
Simon Marlow <marlowsd@gmail.com>**20100316143103
 Ignore-this: ab7ca42904f59a0381ca24f3eb38d314
 
 Fixes a rare crash in the parallel GC.
 
 If we copy a closure non-atomically during GC, as we do for all
 immutable values, then before writing the forwarding pointer we better
 make sure that the closure itself is visible to other threads that
 might follow the forwarding pointer.  I imagine this doesn't happen
 very often, but I just found one case of it: in scavenge_stack, the
 RET_FUN case, after evacuating ret_fun->fun we then follow it and look
 up the info pointer.
] 
[Comments only
benl@ouroborus.net**20100311064518
 Ignore-this: d7dc718cc437d62aa5b1b673059a9b22
] 
[TAG 2010-03-16
Ian Lynagh <igloo@earth.li>**20100316005137
 Ignore-this: 234e3bc29e2f26cc59d7b03d780cc352
] 
Patch bundle hash:
e152a58f1b7cb15f2af23fbd742550571599bf00
