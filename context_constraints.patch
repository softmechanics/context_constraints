Mon Mar  8 15:30:17 PST 2010  matt@softmechanics.net
  * Context Constraints

Sun Mar 14 22:41:58 PDT 2010  matt@softmechanics.net
  * Context Constraints Part 2
  
  Can now correct deduce which instance to use from type variables, in 
  addition to (concrete) types.  lookupPred is still the main driver, 
  and there is still lots of debug code in there, from trying to find the
  best method.  
  
  Two big changes to the simplification loop:  the first is that a function
  that checks if a matching Inst is available (Inst -> TcM Bool) is passed
  down to lookupPred.  This could be remedied by importing findAvail into 
  Inst.lhs.
  
  The second was a simple solution to the problem of deciding an instance
  for type variables too early.  That is, before all the other instances for
  the typeclass parameters have been discovered.  The result of choosing too
  early is that a more general instance is chosen than should be.  I addressed
  the problem by modifing passing a boolean "force" argument to lookupPred, indicating
  that it must choose the best matching instance it can now.  If force is False,
  lookupPred will return an instance only if it is the best possible (i.e. no more specific
  instance exists). 
  
  
  

Tue Mar 16 11:05:20 PDT 2010  matt@softmechanics.net
  * Partial Cleanup

Fri Mar 19 10:27:45 PDT 2010  matt@softmechanics.net
  * Improved force logic in lookupPred

Fri Mar 19 14:45:27 PDT 2010  matt@softmechanics.net
  * Use mutual recursion between applyContextConstraints, lookupPred to lookup context predicates

Sun Mar 21 11:24:44 PDT 2010  matt@softmechanics.net
  * New ContextConstraints extension flag
  
  Removed short-circuit logic to always accept a single matched element as properly constrained without checking.  
  Finally added ContextConstraints extension flag.  
  Added param to propagate force flag throughout applyContextConstraints/lookupPred loop.
  Made ContextConstraints always ignore unified instances.
  

New patches:

[Context Constraints
matt@softmechanics.net**20100308233017
 Ignore-this: 6ffaf8308504978eda2a0c72af9ed137
] {
hunk ./compiler/typecheck/Inst.lhs 753
 		Just specs -> funDepErr ispec' specs
 		Nothing    -> return ()
 
-		-- Check for duplicate instance decls
-	; let { (matches, _) = lookupInstEnv inst_envs cls tys'
-	      ;	dup_ispecs = [ dup_ispec 
-			     | (dup_ispec, _) <- matches
-			     , let (_,_,_,dup_tys) = instanceHead dup_ispec
-			     , isJust (tcMatchTys (mkVarSet tvs') tys' dup_tys)] }
-		-- Find memebers of the match list which ispec itself matches.
-		-- If the match is 2-way, it's a duplicate
-	; case dup_ispecs of
-	    dup_ispec : _ -> dupInstErr ispec' dup_ispec
-	    []            -> return ()
-
 		-- OK, now extend the envt
 	; return (extendInstEnv home_ie ispec') }
 
hunk ./compiler/types/InstEnv.lhs 36
 import UniqFM
 import Id
 import FastString
+import Type (substPred)
 
 import Data.Maybe	( isJust, isNothing )
 \end{code}
hunk ./compiler/types/InstEnv.lhs 450
     (pkg_matches,  pkg_unifs)  = lookup pkg_ie  
     all_matches = home_matches ++ pkg_matches
     all_unifs   = home_unifs   ++ pkg_unifs
-    pruned_matches = foldr insert_overlapping [] all_matches
+    pruned_matches = applyContextConstraints $ foldr insert_overlapping [] all_matches
 	-- Even if the unifs is non-empty (an error situation)
 	-- we still prune the matches, so that the error message isn't
 	-- misleading (complaining of multiple matches when some should be
hunk ./compiler/types/InstEnv.lhs 456
 	-- overlapped away)
 
+    --------------
+    applyContextConstraints x@(_:_:_) = reduceContextMatches $ filter matchesContext x
+    applyContextConstraints x = x
+
+    reduceContextMatches [] = []
+    reduceContextMatches [x] = [x]
+    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
+
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    thetaProperSubset :: ThetaType -> ThetaType -> Bool
+    thetaProperSubset sub super =
+      all inSuper sub
+      where inSuper c = inP c super
+            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+            cmpPred _ _ = False -- TODO: handle other predicates
+
+            inP _ [] = False
+            inP a (b:_) | a `cmpPred` b = True
+            inP a as = inP a $ tail as
+
+    isMostSpecificContext x xs =
+      all (not . thetaProperSubset (theta x)) $ map theta xs
+      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
+
+    matchesContext (match_inst, _) = 
+      all matchesPred theta
+      where (_, theta, _, _) = instanceHead match_inst
+            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
+            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+
+            matchesPred pred@(ClassP _ _) = 
+              case lookupInstEnv (pkg_ie, home_ie) predC predTys of
+                   ([_],_) -> True
+                   (_,_) -> False
+              where (ClassP predC predTys) = substPred subst pred
+            matchesPred _ = False
+
     --------------
     lookup env = case lookupUFM env cls of
 		   Nothing -> ([],[])	-- No instances for this class
}
[Context Constraints Part 2
matt@softmechanics.net**20100315054158
 Ignore-this: 3cff74290775029a8f62469f7de4598f
 
 Can now correct deduce which instance to use from type variables, in 
 addition to (concrete) types.  lookupPred is still the main driver, 
 and there is still lots of debug code in there, from trying to find the
 best method.  
 
 Two big changes to the simplification loop:  the first is that a function
 that checks if a matching Inst is available (Inst -> TcM Bool) is passed
 down to lookupPred.  This could be remedied by importing findAvail into 
 Inst.lhs.
 
 The second was a simple solution to the problem of deciding an instance
 for type variables too early.  That is, before all the other instances for
 the typeclass parameters have been discovered.  The result of choosing too
 early is that a more general instance is chosen than should be.  I addressed
 the problem by modifing passing a boolean "force" argument to lookupPred, indicating
 that it must choose the best matching instance it can now.  If force is False,
 lookupPred will return an instance only if it is the best possible (i.e. no more specific
 instance exists). 
 
 
 
] {
hunk ./compiler/typecheck/Inst.lhs 804
   = NoInstance
   | GenInst [Inst] (LHsExpr TcId)	-- The expression and its needed insts
 
-lookupSimpleInst :: Inst -> TcM LookupInstResult
+lookupSimpleInst :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM LookupInstResult
 -- This is "simple" in that it returns NoInstance for implication constraints
 
 -- It's important that lookupInst does not put any new stuff into
hunk ./compiler/typecheck/Inst.lhs 811
 -- the LIE.  Instead, any Insts needed by the lookup are returned in
 -- the LookupInstResult, where they can be further processed by tcSimplify
 
-lookupSimpleInst (EqInst {}) = return NoInstance
+lookupSimpleInst _ _ (EqInst {}) = return NoInstance
 
 --------------------- Implications ------------------------
hunk ./compiler/typecheck/Inst.lhs 814
-lookupSimpleInst (ImplicInst {}) = return NoInstance
+lookupSimpleInst _ _ (ImplicInst {}) = return NoInstance
 
 --------------------- Methods ------------------------
hunk ./compiler/typecheck/Inst.lhs 817
-lookupSimpleInst (Method {tci_oid = id, tci_tys = tys, tci_theta = theta, tci_loc = loc})
+lookupSimpleInst _ _ (Method {tci_oid = id, tci_tys = tys, tci_theta = theta, tci_loc = loc})
   = do	{ (dict_app, dicts) <- getLIE $ instCallDicts loc theta
 	; let co_fn = dict_app <.> mkWpTyApps tys
 	; return (GenInst dicts (L span $ HsWrap co_fn (HsVar id))) }
hunk ./compiler/typecheck/Inst.lhs 831
 -- [Same shortcut as in newOverloadedLit, but we
 --  may have done some unification by now] 		
 
-lookupSimpleInst (LitInst { tci_lit = lit@OverLit { ol_val = lit_val
+lookupSimpleInst _ _ (LitInst { tci_lit = lit@OverLit { ol_val = lit_val
 					          , ol_rebindable = rebindable }
 			  , tci_ty = ty, tci_loc = iloc})
   | debugIsOn && rebindable = panic "lookupSimpleInst" -- A LitInst invariant
hunk ./compiler/typecheck/Inst.lhs 852
     loc = instLocSpan iloc
 
 --------------------- Dictionaries ------------------------
-lookupSimpleInst (Dict {tci_pred = pred, tci_loc = loc})
-  = do 	{ mb_result <- lookupPred pred
+lookupSimpleInst force availP dct@(Dict {tci_pred = pred, tci_loc = loc})
+  = do 	{ mb_result <- lookupPred force availP dct
 	; case mb_result of {
 	    Nothing -> return NoInstance ;
 	    Just (dfun_id, mb_inst_tys) -> do
hunk ./compiler/typecheck/Inst.lhs 884
     }}}}
 
 ---------------
-lookupPred :: TcPredType -> TcM (Maybe (DFunId, [Either TyVar TcType]))
+applyContextConstraints _ _ _ _ x@([],_) = return x
+applyContextConstraints _ _ _ _ x@([_],_) = return x
+applyContextConstraints inst availP ies tys (ms,us) = 
+  do ms' <- filterM matchesContext ms
+     return (reduceContextMatches ms', us)
+  where
+    reduceContextMatches [] = []
+    reduceContextMatches [x] = [x]
+    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
+
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    isMostSpecificContext x xs =
+      all (not . thetaProperSubset (theta x)) $ map theta xs
+      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
+
+    thetaProperSubset :: ThetaType -> ThetaType -> Bool
+    thetaProperSubset sub super =
+      all inSuper sub
+      where inSuper c = inP c super
+            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+            cmpPred _ _ = False -- TODO: handle other predicates
+
+            inP _ [] = False
+            inP a (b:_) | a `cmpPred` b = True
+            inP a as = inP a $ tail as
+
+    matchesContext match@(match_inst, _) = 
+      do bools <- mapM matchesPred theta
+         return $ and bools
+      where (_, theta, _, _) = instanceHead match_inst
+            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
+            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+
+            matchesPred pred@(ClassP _ _) =
+              do let (ClassP predC predTys) = substPred subst pred
+                 let lookup = lookupInstEnv ies predC predTys 
+                 res <- applyContextConstraints inst availP ies predTys lookup
+                 case res of
+                   ([x],_) -> instMatchAvailP availP inst x
+                   _       -> return False 
+            matchesPred _ = return False
+
+predClassNames inst =
+  map getName theta 
+  where (_, theta, _, _) = instanceHead inst
+        getName (ClassP cls _) = className cls
+
+matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
+matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
+    { use_stage <- getStage
+    ; checkWellStaged (ptext (sLit "instance for") <+> quotes (ppr pred))
+    		      (topIdLvl dfun_id) (thLevel use_stage)
+
+ 	-- It's possible that not all the tyvars are in
+	-- the substitution, tenv. For example:
+	--	instance C X a => D X where ...
+	-- (presumably there's a functional dependency in class C)
+	-- Hence mb_inst_tys :: Either TyVar TcType 
+
+    ; let inst_tv (Left tv)  = do { tv' <- tcInstTyVar tv; return (mkTyVarTy tv') }
+	  inst_tv (Right ty) = return ty
+    ; tys <- mapM inst_tv mb_inst_tys
+    ; let
+    	(theta, _) = tcSplitPhiTy (applyTys (idType dfun_id) tys)
+	src_loc	   = instLocSpan loc
+	dfun	   = HsVar dfun_id
+    ; if null theta then
+        return (GenInst [] (L src_loc $ HsWrap (mkWpTyApps tys) dfun))
+      else do
+    { (dict_app, dicts) <- getLIE $ instCallDicts loc theta -- !!!
+    ; let co_fn = dict_app <.> mkWpTyApps tys
+    ; return (GenInst dicts (L src_loc $ HsWrap co_fn dfun))
+    }}
+
+returnInsts (ispec, inst_tys) = (is_dfun ispec, inst_tys)
+
+maybeGenInst gi@(GenInst dicts _) = Just gi
+maybeGenInst _                    = Nothing
+
+lookupInstResultAvailP :: (Inst -> TcM Bool) -> LookupInstResult -> TcM Bool
+lookupInstResultAvailP availP (GenInst dicts _) =
+  do avails <- mapM availP dicts
+     return $ and avails
+
+--instMatchAvailP :: (Inst -> TcM Bool) -> Inst -> InstMatch -> TcM Bool
+instMatchAvailP availP inst match =
+  do match' <- matchInst inst $ returnInsts match
+     lookupInstResultAvailP availP match'
+     
+-- an instance with zero type variables is THE best match
+-- an instance is "a best match" if no other instance has
+-- all its predicates and more
+bestInstMatches [] = []
+bestInstMatches [x] = [x]
+bestInstMatches (x:xs) = collectMostSpecificContexts [] x xs 
+  where
+--    collectMostSpecificContexts _ x _
+--      | noTypeVariables x
+--        = [x]
+--
+    collectMostSpecificContexts outs x []
+      | isMostSpecificContext x outs
+        = x:outs
+      | otherwise
+        = outs
+
+    collectMostSpecificContexts outs x ins@(x':ins')
+      | isMostSpecificContext x (outs ++ ins)
+        = collectMostSpecificContexts (x:outs) x' ins'
+      | otherwise
+        = collectMostSpecificContexts outs x' ins'
+
+    noTypeVariables x = null $ tyVars x
+    tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
+  
+-- this is a naive match method.  it has no knowledge
+-- of which type variables a pred is predicating.  
+-- so (A a, A b, C c) is a proper subset of (A a, B b, C c),
+-- which is not true.  However, I can't figure out why tcEqPred
+-- always fails on type variables.  Needs unification? Maybe tcMatchTys?
+thetaProperSubset :: ThetaType -> ThetaType -> Bool
+thetaProperSubset subTheta superTheta =
+  -- NO pred exists strictly more times in sub than in super
+  -- SOME pred exists less times in sub than in super 
+
+  (not $ any (hasLess super sub) combined) && (any (hasLess sub super) combined)
+
+  where hasLess t1 t2 c = (count c t1) < (count c t2)
+
+        cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
+        cmpPred _ _ = False -- TODO: handle other predicates
+
+        count _ [] = 0
+        count a (b:bs) | a `cmpPred` b = 1 + (count a bs)
+                       | otherwise     = count a bs
+
+        sub = filter isClassPred subTheta
+        super = filter isClassPred superTheta
+
+        combined = sub ++ super
+
+
+--thetaProperSubset :: ThetaType -> ThetaType -> Bool
+--thetaProperSubset sub super =
+--  (all (hasP super) sub) && (not $ all (hasP sub) super)
+--  where hasP [] _ = False
+--        hasP (b:bs) a | tcEqPred a b = True
+--                      | otherwise    = hasP bs a
+--
+isMoreSpecificInst x y =
+    not $ thetaProperSubset (theta x) (theta y)
+  where theta = instanceTheta.fst
+
+instanceTheta = (\(_,x,_,_) -> x) . instanceHead 
+instanceTyVars = (\(x,_,_,_) -> x) . instanceHead
+
+isMostSpecificContext x xs 
+--  | null $ tyVars x
+--    = True
+--  | otherwise
+    = all (isMoreSpecificInst x) xs
+  where tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
+        xs' = filter (\y -> not $ tcEqTheta (theta x) (theta y)) xs
+        theta = instanceTheta.fst
+
+eqLength x y = (length x) == (length y)
+
+zipWith' f x y
+  | eqLength x y
+    = and $ zipWith f x y
+  | otherwise
+    = False
+
+tcEqTheta = zipWith' eqVarNamesPred
+
+eqVarNamesPred (ClassP c1 vs1) (ClassP c2 vs2) 
+  = c1 == c2 && vs1 `eqVarNamesTypes` vs2
+eqVarNamesPred _ _ = False
+
+eqVarNamesTypes = zipWith' eqVarNamesType
+
+eqVarNamesType (TyVarTy tv1) (TyVarTy tv2) = tv1 `eqVarNamesVar` tv2
+eqVarNamesType (AppTy f1 a1) (AppTy f2 a2) = f1 `eqVarNamesType` f2 && a1 `eqVarNamesType` a2
+eqVarNamesType (TyConApp c1 tys1) (TyConApp c2 tys2) = c1 == c2 && tys1 `eqVarNamesTypes` tys2
+eqVarNamesType (FunTy f1 a1) (FunTy f2 a2) = f1 `eqVarNamesType` f2 && a1 `eqVarNamesType` a2
+eqVarNamesType (ForAllTy tv1 ty1) (ForAllTy tv2 ty2) = tv1 `eqVarNamesVar` tv2 && ty1 `eqVarNamesType` ty2
+
+eqVarNamesVar x y = (getName x) == (getName y)
+
+
+checkAvail _ _ x@([],_) = return x
+checkAvail _ _ x@([_],_) = return x
+checkAvail availP inst (insts,unifs) = 
+  do insts' <- filterM (instMatchAvailP availP inst) insts
+     return (insts', unifs)
+
+tcEqInstMatch' (i1, tys1) (i2, tys2) 
+  = tcEqTheta theta1 theta2
+    where theta1 = instanceTheta i1
+          theta2 = instanceTheta i2
+
+tcEqInstMatch (i1, _) (i2, _) 
+  = case mkInstTypeMap i1 i2 of
+    Nothing -> False
+    (Just tvMap) -> tcEqTheta theta1 theta2
+      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+            -- theta1 = instanceTheta i1
+            theta2 = instanceTheta i2
+
+tcEqInstMatch'' (i1,_) (i2,_)
+  = tcEqTheta theta1 theta2
+  where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+        theta2 = instanceTheta i2
+        tvMap = zip tvs1 tvs2
+        tvs1 = instanceTyVars i1
+        tvs2 = instanceTyVars i2
+
+mapTheta (i1, tys1) (i2, tys2) 
+  = case mkInstTypeMap tys1 tys2 of
+    Nothing -> []
+    (Just tvMap) -> theta1 
+      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
+
+mapTyVarsPreds tvMap = map (mapTyVarsPred tvMap) 
+mapTyVarsPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsTypes tvMap tys
+
+mapTyVarsTypes :: [(TyVar,TyVar)] -> [Type] -> [Type]
+mapTyVarsTypes tvMap tys = map (mapTyVarsType tvMap) tys
+
+mapTyVarsType tvMap (TyVarTy tv) 
+  = TyVarTy $ mapTyVar tvMap tv
+
+mapTyVarsType tvMap (AppTy ty1 ty2) 
+  = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+
+mapTyVarsType tvMap (TyConApp tc tys)
+  = TyConApp tc $ mapTyVarsTypes tvMap tys
+
+mapTyVarsType tvMap (FunTy ty1 ty2)
+  = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+
+mapTyVarsType tvMap (ForAllTy tv ty)
+  = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
+
+mapTyVarsType tvMap (PredTy pred)
+  = PredTy $ mapTyVarsPred tvMap pred
+
+mapTyVar :: [(TyVar, TyVar)] -> TyVar -> TyVar
+mapTyVar tvMap tv 
+  = case lookup' tv of
+    Just tv' -> tv'
+    Nothing  -> tv
+  where lookup' tv1 = find (\(tv2,res) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+
+mkInstTypeMap i1 i2
+  | (length tvs1) == (length tvs2)
+    = Just $ filter (\(v1, v2) -> not $ eqVarNamesVar v1 v2) $ zip tvs1 tvs2
+  | otherwise
+    = Nothing
+  where tvs1 = instanceTyVars i1
+        tvs2 = instanceTyVars i2
+
+--mkInstTypeMap :: [Either TyVar Type] -> [Either TyVar Type] -> Maybe [(TyVar,TyVar)]
+--mkInstTypeMap tys1 tys2 = foldM matchLeft [] $ zip tys1 tys2
+--  where matchLeft ms (Left tv1, Left tv2) = Just ((tv1,tv2):ms)
+--        matchLeft _ _                     = Nothing
+
+-- should always be the same length
+tcEqInstTypes [] [] = True
+tcEqInstTypes (x:xs) (y:ys) = tcEqInstType x y && tcEqInstTypes xs ys
+
+tcEqInstType (Left _) (Right _) = False
+tcEqInstType (Right _) (Left _) = False
+tcEqInstType (Left _) (Left _) = True
+tcEqInstType (Right ty1) (Right ty2) = tcEqType ty1 ty2
+
+testInstMatchCompare [] = return ()
+testInstMatchCompare (inst:rest) =
+  do { mapM (testInstMatchCompare' inst) rest
+     ; testInstMatchCompare rest }
+
+testInstMatchCompare' m1@(i1,_) m2@(i2,_) =  
+  do { traceTc (text "MATT: COMPARING INSTS" <+> (ppr [m1,m2]))
+     ; let tys1 = instanceTyVars i1
+     ; let tys2 = instanceTyVars i2
+
+     ; traceTc (text "INST1 VARS: " <+> (ppr tys1))
+     ; traceTc (text "INST2 VARS: " <+> (ppr tys2))
+     ; case tcEqInstMatch m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch OK" )
+     ; case tcEqInstMatch' m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch' FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch' OK" )
+     ; case tcEqInstMatch'' m1 m2 of
+            False -> traceTc (text "MATT: tcEqInstMatch'' FAILED")
+            True -> traceTc (text "MATT: tcEqInstMatch'' OK" )
+     ; return () }
+  
+
+removeDuplicates [] = []
+removeDuplicates [a] = [a]
+removeDuplicates (a:as)
+  | isDuplicate a = removeDuplicates as
+  | otherwise     = a:(removeDuplicates as)
+  where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
+--        cmp (i1,_) (i2,_) = (theta i1) `tcEqTheta` (theta i2)
+--        theta = (\(_,t,_,_)->t).instanceHead
+
+lookupPred :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
hunk ./compiler/typecheck/Inst.lhs 1206
-lookupPred pred@(ClassP clas tys)
-  = do	{ eps     <- getEps
+lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys), tci_loc = loc})
+  = do	{ ; eps     <- getEps
 	; tcg_env <- getGblEnv
 	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
hunk ./compiler/typecheck/Inst.lhs 1210
-	; case lookupInstEnv inst_envs clas tys of {
+	; let insts = lookupInstEnv inst_envs clas tys 
+  ; let (inst_matches, inst_unifs) = insts
+  ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
+
+	-- TODO: check for ContextConstraints flag
+  case force of
+      True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
+      False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
+  ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
+	; constrained <- applyContextConstraints inst availP inst_envs tys insts 
+  ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
+  ; avail_insts <- checkAvail availP inst insts
+  ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
+  ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
+  ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
+	; avail_insts' <- applyContextConstraints inst availP inst_envs tys avail_insts
+  ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
+  ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
+  ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
+  ; testInstMatchCompare $ fst both_dupes
+  ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
+  ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
+  ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
+  ; traceTc (text "MATT: BEST OF BOTH WORLDS" <+> (ppr best_both))
+  ; let (best_matches, _) = best_both
+  ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
+  ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
+  ; let final = case (not force) && (isTyVarDict inst) of
+                     -- if there are unconstrained type vars, don't decide yet
+                     -- XXX This is a hack, and *should not* work in general
+                     True -> (best_possible, [])
+
+                     -- time to decide. pick the best match(es).  No guarantee we're not still
+                     -- deciding too early.
+                     False -> best_both 
+  ; traceTc (text "MATT: DONE: " <+> (ppr final))
+	; case final of {
 	    ([(ispec, inst_tys)], []) 
 		-> do	{ let dfun_id = is_dfun ispec
 			; traceTc (text "lookupInst success" <+> 
hunk ./compiler/typecheck/Inst.lhs 1270
 			; return Nothing }
 	}}
 
-lookupPred (IParam {}) = return Nothing	-- Implicit parameters
-lookupPred (EqPred {}) = panic "lookupPred EqPred"
+lookupPred _ _ (Dict {tci_pred = (IParam {})}) = return Nothing	-- Implicit parameters
+lookupPred _ _ (Dict {tci_pred = (EqPred {})}) = panic "lookupPred EqPred"
 
 record_dfun_usage :: Id -> TcRn ()
 record_dfun_usage dfun_id 
hunk ./compiler/typecheck/TcSimplify.lhs 62
 
 import Control.Monad
 import Data.List
+import Data.Maybe
 \end{code}
 
 
hunk ./compiler/typecheck/TcSimplify.lhs 1036
         }
 
 -----------------------------------------------------------
+tryReallyHardCheckLoop :: SDoc
+	     -> [Inst]			-- Wanted
+	     -> TcM ([Inst], TcDictBinds)
+
+tryReallyHardCheckLoop doc wanteds
+  = do { (irreds,binds) <- forceCheckLoop (mkInferRedEnv doc try_me) wanteds
+       ; return (irreds,binds)
+       }
+  where
+    try_me _ = ReduceMe
+	-- Here's the try-hard bit
+
 tryHardCheckLoop :: SDoc
 	     -> [Inst]			-- Wanted
 	     -> TcM ([Inst], TcDictBinds)
hunk ./compiler/typecheck/TcSimplify.lhs 1115
 
 \begin{code}
 -----------------------------------------------------------
+checkLoop' True = forceCheckLoop
+checkLoop' False = checkLoop
+
+forceCheckLoop :: RedEnv
+	  -> [Inst]			-- Wanted
+	  -> TcM ([Inst], TcDictBinds) 
+-- Precondition: givens are completely rigid
+-- Postcondition: returned Insts are zonked
+
+forceCheckLoop env wanteds
+  = go env wanteds
+  where go env wanteds
+	  = do  {  -- We do need to zonk the givens; cf Note [Zonking RedEnv]
+                ; traceTc (text "MATT: entering forceCheckLoop ")
+                ; env'     <- zonkRedEnv env
+		; wanteds' <- zonkInsts  wanteds
+	
+		; (improved, tybinds, binds, irreds) 
+                    <- reduceContext env' wanteds'
+                ; execTcTyVarBinds tybinds
+    --; if null irreds || not improved then
+    ; if not improved then
+        do {
+            ;(improved1, tybinds1, binds1, irreds1)
+                    <- forceReduceContext env' wanteds'
+            ; execTcTyVarBinds tybinds1
+            ; if null irreds1 || not improved1 then
+                do {
+                    ; traceTc (text "MATT: forceCheckLoop exiting")
+                    ; return (irreds1, binds1) }
+              else do { 
+                ; (irreds2, binds2) <- go env' irreds1
+                ; return (irreds2, binds1 `unionBags` binds2) } }
+        else do	
+		-- If improvement did some unification, we go round again.
+		-- We start again with irreds, not wanteds
+		-- Using an instance decl might have introduced a fresh type
+		-- variable which might have been unified, so we'd get an 
+                -- infinite loop if we started again with wanteds!  
+                -- See Note [LOOP]
+		{ (irreds1, binds1) <- go env' irreds
+		; return (irreds1, binds `unionBags` binds1) } }
 checkLoop :: RedEnv
 	  -> [Inst]			-- Wanted
 	  -> TcM ([Inst], TcDictBinds) 
hunk ./compiler/typecheck/TcSimplify.lhs 1167
   = go env wanteds
   where go env wanteds
 	  = do  {  -- We do need to zonk the givens; cf Note [Zonking RedEnv]
+                ; traceTc (text "MATT: entering checkLoop ")
                 ; env'     <- zonkRedEnv env
 		; wanteds' <- zonkInsts  wanteds
 	
hunk ./compiler/typecheck/TcSimplify.lhs 1176
                 ; execTcTyVarBinds tybinds
 
 		; if null irreds || not improved then
-	 	    return (irreds, binds)
+        do {
+            ; traceTc (text "MATT: checkLoop exiting")
+	 	        ; return (irreds, binds) }
 		  else do
 	
 		-- If improvement did some unification, we go round again.
hunk ./compiler/typecheck/TcSimplify.lhs 1680
 	| otherwise
 	= do { w' <- zonkInst w  -- So that (3::Int) does not generate a call
 				 -- to fromInteger; this looks fragile to me
-	     ; lookup_result <- lookupSimpleInst w'
+	     ; lookup_result <- lookupSimpleInst False (\_ -> return False) w'
 	     ; case lookup_result of
 		 NoInstance      -> go (w:irreds) binds ws
 		 GenInst ws' rhs -> go irreds binds' (ws' ++ ws)
hunk ./compiler/typecheck/TcSimplify.lhs 1942
 		      TcDictBinds,	-- Dictionary bindings
 		      [Inst])		-- Irreducible
 
-reduceContext env wanteds0
-  = do	{ traceTc (text "reduceContext" <+> (vcat [
+reduceContext = reduceContext' False
+forceReduceContext = reduceContext' True
+reduceContext' force env wanteds0
+  = do	{ 
+    ;if force then traceTc (text "MATT: reduceContext' FORCE")
+      else traceTc (text "MATT reduceContext'")
+   ;traceTc (text "reduceContext" <+> (vcat [
 	     text "----------------------",
 	     red_doc env,
 	     text "given" <+> ppr (red_givens env),
hunk ./compiler/typecheck/TcSimplify.lhs 1987
           -- of improvement due to functional dependencies if any of the
           -- involved unifications gets deferred.
 	; let (wanted_implics, wanted_dicts) = partition isImplicInst wanteds'
-	; (avails, extra_eqs) <- getLIE (reduceList env wanted_dicts init_state)
+	; (avails, extra_eqs) <- getLIE (reduceList' force env wanted_dicts init_state)
 	  	   -- The getLIE is reqd because reduceList does improvement
 		   -- (via extendAvails) which may in turn do unification
 	; (dict_binds, 
hunk ./compiler/typecheck/TcSimplify.lhs 2007
                                    = givens ++ bound_dicts ++
                                      map wantedToLocalEqInst dict_irreds }
 	; (implic_binds_s, implic_irreds_s) 
-            <- mapAndUnzipM (reduceImplication implic_env) wanted_implics
+            <- mapAndUnzipM (reduceImplication' force implic_env) wanted_implics
 	; let implic_binds  = unionManyBags implic_binds_s
 	      implic_irreds = concat implic_irreds_s
 
hunk ./compiler/typecheck/TcSimplify.lhs 2035
               improvedHint  = (if avails_improved then " [AVAILS]" else "") ++
                               (if eq_improved then " [EQ]" else "")
 
+  ; if force then traceTc (text "MATT: reduceContext FORCE")
+  else traceTc (text "MATT: reduceContext FORCE")
 	; traceTc (text "reduceContext end" <+> (vcat [
 	     text "----------------------",
 	     red_doc env,
hunk ./compiler/typecheck/TcSimplify.lhs 2158
 The main context-reduction function is @reduce@.  Here's its game plan.
 
 \begin{code}
-reduceList :: RedEnv -> [Inst] -> Avails -> TcM Avails
-reduceList env@(RedEnv {red_stack = (n,stk)}) wanteds state
-  = do	{ traceTc (text "reduceList " <+> (ppr wanteds $$ ppr state))
+--reduceList :: RedEnv -> [Inst] -> Avails -> TcM Avails
+--reduceList = reduceList' False
+reduceList' force env@(RedEnv {red_stack = (n,stk)}) wanteds state
+  = do	{ 
+  ; (case force of
+      True -> traceTc (text "reduceList (FORCE) " <+> (ppr wanteds $$ ppr state))
+      False -> traceTc (text "reduceList " <+> (ppr wanteds $$ ppr state)))
 	; dopts <- getDOpts
 	; when (debugIsOn && (n > 8)) $ do
 		debugDumpTcRn (hang (ptext (sLit "Interesting! Context reduction stack depth") <+> int n) 
hunk ./compiler/typecheck/TcSimplify.lhs 2175
 	    go wanteds state }
   where
     go []     state = return state
-    go (w:ws) state = do { state' <- reduce (env {red_stack = (n+1, w:stk)}) w state
+    go (w:ws) state = do { state' <- reduce' force (env {red_stack = (n+1, w:stk)}) w state
 			 ; go ws state' }
 
     -- Base case: we're done!
hunk ./compiler/typecheck/TcSimplify.lhs 2180
 reduce :: RedEnv -> Inst -> Avails -> TcM Avails
-reduce env wanted avails
+reduce = reduce' False
+reduce' force env wanted avails
 
     -- We don't reduce equalities here (and they must not end up as irreds
     -- in the Avails!)
hunk ./compiler/typecheck/TcSimplify.lhs 2195
        }
 
   | otherwise
-  = do	{ traceTc (text "reduce" <+> ppr wanted $$ ppr avails)
+  = do	{ 
+  ; (case force of 
+      True -> traceTc (text "reduce (FORCE)" <+> ppr wanted $$ ppr avails)
+      False -> traceTc (text "reduce" <+> ppr wanted $$ ppr avails))
 	; case red_try_me env wanted of {
 	    Stop -> try_simple (addIrred NoSCs);
 			-- See Note [No superclasses for Stop]
hunk ./compiler/typecheck/TcSimplify.lhs 2204
 
 	    ReduceMe -> do	-- It should be reduced
-		{ (avails, lookup_result) <- reduceInst env avails wanted
+		{ (avails, lookup_result) <- reduceInst force env avails wanted
 		; case lookup_result of
 		    NoInstance -> addIrred AddSCs avails wanted
 			     -- Add it and its superclasses
hunk ./compiler/typecheck/TcSimplify.lhs 2213
 
 		    GenInst wanteds' rhs
 			  -> do	{ avails1 <- addIrred NoSCs avails wanted
-				; avails2 <- reduceList env wanteds' avails1
+				; avails2 <- reduceList' force env wanteds' avails1
 				; addWanted AddSCs avails2 wanted rhs wanteds' } }
 		-- Temporarily do addIrred *before* the reduceList, 
 		-- which has the effect of adding the thing we are trying
hunk ./compiler/typecheck/TcSimplify.lhs 2229
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst wanted
+      = do { res <- lookupSimpleInst force (return . isJust . findAvail avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
hunk ./compiler/typecheck/TcSimplify.lhs 2322
 
 \begin{code}
 ---------------------------------------------
-reduceInst :: RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
-reduceInst _ avails other_inst
-  = do	{ result <- lookupSimpleInst other_inst
+reduceInst :: Bool -> RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
+reduceInst force _ avails other_inst
+  = do	{ result <- lookupSimpleInst force (return . isJust . findAvail avails) other_inst
 	; return (avails, result) }
 \end{code}
 
hunk ./compiler/typecheck/TcSimplify.lhs 2400
         -- where cotv is a simple coercion type variable (and not a more
         -- complex coercion term).  We require that the extra_givens always
         -- have this form and exploit the special form when generating binders.
-reduceImplication env
+reduceImplication = reduceImplication' False
+reduceImplication' force env
 	orig_implic@(ImplicInst { tci_name = name, tci_loc = inst_loc,
 		      	   	  tci_tyvars = tvs,
 		      	   	  tci_given = extra_givens, tci_wanted = wanteds
hunk ./compiler/typecheck/TcSimplify.lhs 2418
 	; traceTc (text "reduceImplication" <+> vcat
 			[ ppr (red_givens env), ppr extra_givens, 
 			  ppr wanteds])
-	; (irreds, binds) <- checkLoop env' wanteds
+	; (irreds, binds) <- checkLoop' force env' wanteds
 
 	; traceTc (text "reduceImplication result" <+> vcat
 			[ppr irreds, ppr binds])
hunk ./compiler/typecheck/TcSimplify.lhs 2483
 		  simpler_implic_insts)
   	} 
     }
-reduceImplication _ i = pprPanic "reduceImplication" (ppr i)
+reduceImplication' _ _ i = pprPanic "reduceImplication" (ppr i)
 \end{code}
 
 Note [Always inline implication constraints]
hunk ./compiler/typecheck/TcSimplify.lhs 2857
 	; mapM_ zonkTopTyVar (varSetElems (tyVarsOfInsts wanteds))
 
 	; traceTc (text "tc_simplify_top 0: " <+> ppr wanteds)
-	; (irreds1, binds1) <- tryHardCheckLoop doc1 wanteds
+	; (irreds1, binds1) <- tryReallyHardCheckLoop doc1 wanteds
 --	; (irreds1, binds1) <- gentleInferLoop doc1 wanteds
 	; traceTc (text "tc_simplify_top 1: " <+> ppr irreds1)
 	; (irreds2, binds2) <- approximateImplications doc2 (\_ -> True) irreds1
hunk ./compiler/types/InstEnv.lhs 36
 import UniqFM
 import Id
 import FastString
-import Type (substPred)
 
 import Data.Maybe	( isJust, isNothing )
 \end{code}
hunk ./compiler/types/InstEnv.lhs 449
     (pkg_matches,  pkg_unifs)  = lookup pkg_ie  
     all_matches = home_matches ++ pkg_matches
     all_unifs   = home_unifs   ++ pkg_unifs
-    pruned_matches = applyContextConstraints $ foldr insert_overlapping [] all_matches
+    pruned_matches = foldr insert_overlapping [] all_matches
 	-- Even if the unifs is non-empty (an error situation)
 	-- we still prune the matches, so that the error message isn't
 	-- misleading (complaining of multiple matches when some should be
hunk ./compiler/types/InstEnv.lhs 455
 	-- overlapped away)
 
-    --------------
-    applyContextConstraints x@(_:_:_) = reduceContextMatches $ filter matchesContext x
-    applyContextConstraints x = x
-
-    reduceContextMatches [] = []
-    reduceContextMatches [x] = [x]
-    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
-
-    collectMostSpecificContexts outs x []
-      | isMostSpecificContext x outs
-        = x:outs
-      | otherwise
-        = outs
-
-    collectMostSpecificContexts outs x ins@(x':ins')
-      | isMostSpecificContext x (outs ++ ins)
-        = collectMostSpecificContexts (x:outs) x' ins'
-      | otherwise
-        = collectMostSpecificContexts outs x' ins'
-
-    thetaProperSubset :: ThetaType -> ThetaType -> Bool
-    thetaProperSubset sub super =
-      all inSuper sub
-      where inSuper c = inP c super
-            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
-            cmpPred _ _ = False -- TODO: handle other predicates
-
-            inP _ [] = False
-            inP a (b:_) | a `cmpPred` b = True
-            inP a as = inP a $ tail as
-
-    isMostSpecificContext x xs =
-      all (not . thetaProperSubset (theta x)) $ map theta xs
-      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
-
-    matchesContext (match_inst, _) = 
-      all matchesPred theta
-      where (_, theta, _, _) = instanceHead match_inst
-            (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
-            (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
-
-            matchesPred pred@(ClassP _ _) = 
-              case lookupInstEnv (pkg_ie, home_ie) predC predTys of
-                   ([_],_) -> True
-                   (_,_) -> False
-              where (ClassP predC predTys) = substPred subst pred
-            matchesPred _ = False
-
     --------------
     lookup env = case lookupUFM env cls of
 		   Nothing -> ([],[])	-- No instances for this class
}
[Partial Cleanup
matt@softmechanics.net**20100316180520
 Ignore-this: 842291f863dbd182678882279c91abd6
] {
hunk ./compiler/typecheck/Inst.lhs 884
     }}}}
 
 ---------------
+applyContextConstraints :: Inst -> 
+                           (Inst -> TcM Bool) -> 
+                           (InstEnv, InstEnv) -> 
+                           [Type] -> 
+                           ([(Instance,[Either TyVar Type])], [Instance]) -> 
+                           IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
 applyContextConstraints _ _ _ _ x@([],_) = return x
 applyContextConstraints _ _ _ _ x@([_],_) = return x
 applyContextConstraints inst availP ies tys (ms,us) = 
hunk ./compiler/typecheck/Inst.lhs 894
   do ms' <- filterM matchesContext ms
-     return (reduceContextMatches ms', us)
+     return (bestInstMatches ms', us)
   where
hunk ./compiler/typecheck/Inst.lhs 896
-    reduceContextMatches [] = []
-    reduceContextMatches [x] = [x]
-    reduceContextMatches (x:xs) = collectMostSpecificContexts [] x xs
-
-    collectMostSpecificContexts outs x []
-      | isMostSpecificContext x outs
-        = x:outs
-      | otherwise
-        = outs
-
-    collectMostSpecificContexts outs x ins@(x':ins')
-      | isMostSpecificContext x (outs ++ ins)
-        = collectMostSpecificContexts (x:outs) x' ins'
-      | otherwise
-        = collectMostSpecificContexts outs x' ins'
-
-    isMostSpecificContext x xs =
-      all (not . thetaProperSubset (theta x)) $ map theta xs
-      where theta = (\(_,x,_,_) -> x) . instanceHead . fst
-
-    thetaProperSubset :: ThetaType -> ThetaType -> Bool
-    thetaProperSubset sub super =
-      all inSuper sub
-      where inSuper c = inP c super
-            cmpPred (ClassP c1 _) (ClassP c2 _) = c1 == c2
-            cmpPred _ _ = False -- TODO: handle other predicates
-
-            inP _ [] = False
-            inP a (b:_) | a `cmpPred` b = True
-            inP a as = inP a $ tail as
-
-    matchesContext match@(match_inst, _) = 
-      do bools <- mapM matchesPred theta
+    matchesContext (match_inst, _) = 
+      do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
+         traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
+         bools <- mapM matchesPred theta
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
hunk ./compiler/typecheck/Inst.lhs 904
             (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
+            theta' = map (substPred subst) theta
 
             matchesPred pred@(ClassP _ _) =
               do let (ClassP predC predTys) = substPred subst pred
hunk ./compiler/typecheck/Inst.lhs 909
                  let lookup = lookupInstEnv ies predC predTys 
+                 traceTc (text "MATT: matchesPred matches" <+> (ppr lookup))
                  res <- applyContextConstraints inst availP ies predTys lookup
hunk ./compiler/typecheck/Inst.lhs 911
+                 traceTc (text "MATT: matchesPred constrained matches" <+> (ppr res))
                  case res of
                    ([x],_) -> instMatchAvailP availP inst x
                    _       -> return False 
hunk ./compiler/typecheck/Inst.lhs 917
             matchesPred _ = return False
 
-predClassNames inst =
-  map getName theta 
-  where (_, theta, _, _) = instanceHead inst
-        getName (ClassP cls _) = className cls
-
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
     { use_stage <- getStage
hunk ./compiler/typecheck/Inst.lhs 944
     ; return (GenInst dicts (L src_loc $ HsWrap co_fn dfun))
     }}
 
-returnInsts (ispec, inst_tys) = (is_dfun ispec, inst_tys)
-
-maybeGenInst gi@(GenInst dicts _) = Just gi
-maybeGenInst _                    = Nothing
-
 lookupInstResultAvailP :: (Inst -> TcM Bool) -> LookupInstResult -> TcM Bool
 lookupInstResultAvailP availP (GenInst dicts _) =
   do avails <- mapM availP dicts
hunk ./compiler/typecheck/Inst.lhs 949
      return $ and avails
 
---instMatchAvailP :: (Inst -> TcM Bool) -> Inst -> InstMatch -> TcM Bool
-instMatchAvailP availP inst match =
-  do match' <- matchInst inst $ returnInsts match
+instMatchAvailP :: (Inst -> TcM Bool) -> 
+                   Inst -> 
+                   (Instance, [Either TyVar TcType]) -> 
+                   IOEnv (Env TcGblEnv TcLclEnv) Bool
+instMatchAvailP availP inst (ispec, inst_tys) =
+  do match' <- matchInst inst (is_dfun ispec, inst_tys)
      lookupInstResultAvailP availP match'
      
hunk ./compiler/typecheck/Inst.lhs 957
--- an instance with zero type variables is THE best match
--- an instance is "a best match" if no other instance has
--- all its predicates and more
+bestInstMatches :: [(Instance, [Either TyVar Type])] -> [(Instance, [Either TyVar Type])]
 bestInstMatches [] = []
 bestInstMatches [x] = [x]
 bestInstMatches (x:xs) = collectMostSpecificContexts [] x xs 
hunk ./compiler/typecheck/Inst.lhs 962
   where
---    collectMostSpecificContexts _ x _
---      | noTypeVariables x
---        = [x]
---
     collectMostSpecificContexts outs x []
       | isMostSpecificContext x outs
         = x:outs
hunk ./compiler/typecheck/Inst.lhs 973
         = collectMostSpecificContexts (x:outs) x' ins'
       | otherwise
         = collectMostSpecificContexts outs x' ins'
-
-    noTypeVariables x = null $ tyVars x
-    tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
   
hunk ./compiler/typecheck/Inst.lhs 974
--- this is a naive match method.  it has no knowledge
--- of which type variables a pred is predicating.  
--- so (A a, A b, C c) is a proper subset of (A a, B b, C c),
--- which is not true.  However, I can't figure out why tcEqPred
--- always fails on type variables.  Needs unification? Maybe tcMatchTys?
 thetaProperSubset :: ThetaType -> ThetaType -> Bool
 thetaProperSubset subTheta superTheta =
   -- NO pred exists strictly more times in sub than in super
hunk ./compiler/typecheck/Inst.lhs 995
 
         combined = sub ++ super
 
-
---thetaProperSubset :: ThetaType -> ThetaType -> Bool
---thetaProperSubset sub super =
---  (all (hasP super) sub) && (not $ all (hasP sub) super)
---  where hasP [] _ = False
---        hasP (b:bs) a | tcEqPred a b = True
---                      | otherwise    = hasP bs a
---
-isMoreSpecificInst x y =
-    not $ thetaProperSubset (theta x) (theta y)
+isMoreSpecificInst :: (Instance, [Either TyVar Type]) -> (Instance, [Either TyVar Type]) -> Bool
+isMoreSpecificInst x y 
+    = not $ thetaProperSubset (theta x) (theta y)
   where theta = instanceTheta.fst
 
hunk ./compiler/typecheck/Inst.lhs 1000
+instanceTheta :: Instance -> ThetaType
 instanceTheta = (\(_,x,_,_) -> x) . instanceHead 
hunk ./compiler/typecheck/Inst.lhs 1002
+instanceTyVars :: Instance -> [TyVar]
 instanceTyVars = (\(x,_,_,_) -> x) . instanceHead
 
hunk ./compiler/typecheck/Inst.lhs 1005
+isMostSpecificContext :: (Instance, [Either TyVar Type])
+                      -> [(Instance, [Either TyVar Type])]
+                      -> Bool
 isMostSpecificContext x xs 
hunk ./compiler/typecheck/Inst.lhs 1009
---  | null $ tyVars x
---    = True
---  | otherwise
     = all (isMoreSpecificInst x) xs
hunk ./compiler/typecheck/Inst.lhs 1010
-  where tyVars = (\(x,_,_,_) -> x) . instanceHead . fst
-        xs' = filter (\y -> not $ tcEqTheta (theta x) (theta y)) xs
-        theta = instanceTheta.fst
-
-eqLength x y = (length x) == (length y)
 
hunk ./compiler/typecheck/Inst.lhs 1011
+zipWith' :: (a -> a1 -> Bool) -> [a] -> [a1] -> Bool
 zipWith' f x y
   | eqLength x y
     = and $ zipWith f x y
hunk ./compiler/typecheck/Inst.lhs 1017
   | otherwise
     = False
+  where eqLength x y = (length x) == (length y)
 
 tcEqTheta = zipWith' eqVarNamesPred
 
hunk ./compiler/typecheck/Inst.lhs 1021
+eqVarNamesPred :: PredType -> PredType -> Bool
 eqVarNamesPred (ClassP c1 vs1) (ClassP c2 vs2) 
   = c1 == c2 && vs1 `eqVarNamesTypes` vs2
 eqVarNamesPred _ _ = False
hunk ./compiler/typecheck/Inst.lhs 1036
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
-
 checkAvail _ _ x@([],_) = return x
 checkAvail _ _ x@([_],_) = return x
 checkAvail availP inst (insts,unifs) = 
hunk ./compiler/typecheck/Inst.lhs 1042
   do insts' <- filterM (instMatchAvailP availP inst) insts
      return (insts', unifs)
 
-tcEqInstMatch' (i1, tys1) (i2, tys2) 
-  = tcEqTheta theta1 theta2
-    where theta1 = instanceTheta i1
-          theta2 = instanceTheta i2
-
 tcEqInstMatch (i1, _) (i2, _) 
   = case mkInstTypeMap i1 i2 of
     Nothing -> False
hunk ./compiler/typecheck/Inst.lhs 1047
     (Just tvMap) -> tcEqTheta theta1 theta2
       where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-            -- theta1 = instanceTheta i1
             theta2 = instanceTheta i2
 
hunk ./compiler/typecheck/Inst.lhs 1049
-tcEqInstMatch'' (i1,_) (i2,_)
-  = tcEqTheta theta1 theta2
-  where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-        theta2 = instanceTheta i2
-        tvMap = zip tvs1 tvs2
-        tvs1 = instanceTyVars i1
-        tvs2 = instanceTyVars i2
-
-mapTheta (i1, tys1) (i2, tys2) 
-  = case mkInstTypeMap tys1 tys2 of
-    Nothing -> []
-    (Just tvMap) -> theta1 
-      where theta1 = mapTyVarsPreds tvMap $ instanceTheta i1
-
 mapTyVarsPreds tvMap = map (mapTyVarsPred tvMap) 
 mapTyVarsPred tvMap (ClassP cls tys) = ClassP cls $ mapTyVarsTypes tvMap tys
 
hunk ./compiler/typecheck/Inst.lhs 1055
 mapTyVarsTypes :: [(TyVar,TyVar)] -> [Type] -> [Type]
 mapTyVarsTypes tvMap tys = map (mapTyVarsType tvMap) tys
 
-mapTyVarsType tvMap (TyVarTy tv) 
-  = TyVarTy $ mapTyVar tvMap tv
-
-mapTyVarsType tvMap (AppTy ty1 ty2) 
-  = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
-
-mapTyVarsType tvMap (TyConApp tc tys)
-  = TyConApp tc $ mapTyVarsTypes tvMap tys
-
-mapTyVarsType tvMap (FunTy ty1 ty2)
-  = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
-
-mapTyVarsType tvMap (ForAllTy tv ty)
-  = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
-
-mapTyVarsType tvMap (PredTy pred)
-  = PredTy $ mapTyVarsPred tvMap pred
+mapTyVarsType tvMap (TyVarTy tv) = TyVarTy $ mapTyVar tvMap tv
+mapTyVarsType tvMap (AppTy ty1 ty2) = AppTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+mapTyVarsType tvMap (TyConApp tc tys) = TyConApp tc $ mapTyVarsTypes tvMap tys
+mapTyVarsType tvMap (FunTy ty1 ty2) = FunTy (mapTyVarsType tvMap ty1) (mapTyVarsType tvMap ty2)
+mapTyVarsType tvMap (ForAllTy tv ty) = ForAllTy (mapTyVar tvMap tv) (mapTyVarsType tvMap ty)
+mapTyVarsType tvMap (PredTy pred) = PredTy $ mapTyVarsPred tvMap pred
 
 mapTyVar :: [(TyVar, TyVar)] -> TyVar -> TyVar
 mapTyVar tvMap tv 
hunk ./compiler/typecheck/Inst.lhs 1067
   = case lookup' tv of
     Just tv' -> tv'
     Nothing  -> tv
-  where lookup' tv1 = find (\(tv2,res) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
+  where lookup' tv1 = find (\(tv2,_) -> eqVarNamesVar tv1 tv2) tvMap >>= Just . snd
 
hunk ./compiler/typecheck/Inst.lhs 1069
+mkInstTypeMap :: Instance -> Instance -> Maybe [(TyVar, TyVar)]
 mkInstTypeMap i1 i2
   | (length tvs1) == (length tvs2)
     = Just $ filter (\(v1, v2) -> not $ eqVarNamesVar v1 v2) $ zip tvs1 tvs2
hunk ./compiler/typecheck/Inst.lhs 1078
   where tvs1 = instanceTyVars i1
         tvs2 = instanceTyVars i2
 
---mkInstTypeMap :: [Either TyVar Type] -> [Either TyVar Type] -> Maybe [(TyVar,TyVar)]
---mkInstTypeMap tys1 tys2 = foldM matchLeft [] $ zip tys1 tys2
---  where matchLeft ms (Left tv1, Left tv2) = Just ((tv1,tv2):ms)
---        matchLeft _ _                     = Nothing
-
 -- should always be the same length
hunk ./compiler/typecheck/Inst.lhs 1079
-tcEqInstTypes [] [] = True
+tcEqInstTypes [] []         = True
 tcEqInstTypes (x:xs) (y:ys) = tcEqInstType x y && tcEqInstTypes xs ys
hunk ./compiler/typecheck/Inst.lhs 1081
+tcEqInstTypes _ _           = False
 
 tcEqInstType (Left _) (Right _) = False
 tcEqInstType (Right _) (Left _) = False
hunk ./compiler/typecheck/Inst.lhs 1088
 tcEqInstType (Left _) (Left _) = True
 tcEqInstType (Right ty1) (Right ty2) = tcEqType ty1 ty2
 
-testInstMatchCompare [] = return ()
-testInstMatchCompare (inst:rest) =
-  do { mapM (testInstMatchCompare' inst) rest
-     ; testInstMatchCompare rest }
-
-testInstMatchCompare' m1@(i1,_) m2@(i2,_) =  
-  do { traceTc (text "MATT: COMPARING INSTS" <+> (ppr [m1,m2]))
-     ; let tys1 = instanceTyVars i1
-     ; let tys2 = instanceTyVars i2
-
-     ; traceTc (text "INST1 VARS: " <+> (ppr tys1))
-     ; traceTc (text "INST2 VARS: " <+> (ppr tys2))
-     ; case tcEqInstMatch m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch OK" )
-     ; case tcEqInstMatch' m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch' FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch' OK" )
-     ; case tcEqInstMatch'' m1 m2 of
-            False -> traceTc (text "MATT: tcEqInstMatch'' FAILED")
-            True -> traceTc (text "MATT: tcEqInstMatch'' OK" )
-     ; return () }
-  
 
hunk ./compiler/typecheck/Inst.lhs 1089
+removeDuplicates :: [(Instance, [Either TyVar TcType])] -> [(Instance, [Either TyVar TcType])]
 removeDuplicates [] = []
 removeDuplicates [a] = [a]
 removeDuplicates (a:as)
hunk ./compiler/typecheck/Inst.lhs 1096
   | isDuplicate a = removeDuplicates as
   | otherwise     = a:(removeDuplicates as)
   where isDuplicate a = isJust $ find (tcEqInstMatch a) as 
---        cmp (i1,_) (i2,_) = (theta i1) `tcEqTheta` (theta i2)
---        theta = (\(_,t,_,_)->t).instanceHead
 
 lookupPred :: Bool -> (Inst -> TcM Bool) -> Inst -> TcM (Maybe (DFunId, [Either TyVar TcType]))
 -- Look up a class constraint in the instance environment
hunk ./compiler/typecheck/Inst.lhs 1099
-lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys), tci_loc = loc})
+lookupPred force availP inst@(Dict {tci_pred = pred@(ClassP clas tys)})
   = do	{ ; eps     <- getEps
 	; tcg_env <- getGblEnv
 	; let inst_envs = (eps_inst_env eps, tcg_inst_env tcg_env)
hunk ./compiler/typecheck/Inst.lhs 1104
 	; let insts = lookupInstEnv inst_envs clas tys 
-  ; let (inst_matches, inst_unifs) = insts
+  ; let inst_matches = fst insts
   ; ASSERT( and $ map ((\x -> tcEqInstTypes x x).snd) inst_matches)
 
 	-- TODO: check for ContextConstraints flag
hunk ./compiler/typecheck/Inst.lhs 1122
   ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
   ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
-  ; testInstMatchCompare $ fst both_dupes
   ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS" <+> (ppr both))
   ; let best_both = (\(x,y) -> (bestInstMatches x, y)) both
}
[Improved force logic in lookupPred
matt@softmechanics.net**20100319172745
 Ignore-this: b8c4d5324d24c1a6f943e679ada79202
] {
hunk ./compiler/typecheck/Inst.lhs 1129
   ; let (best_matches, _) = best_both
   ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
   ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
-  ; let final = case (not force) && (isTyVarDict inst) of
-                     -- if there are unconstrained type vars, don't decide yet
-                     -- XXX This is a hack, and *should not* work in general
-                     True -> (best_possible, [])
-
-                     -- time to decide. pick the best match(es).  No guarantee we're not still
+  ; let final = case force of
+                     -- time to decide. pick the best match(es).
                      -- deciding too early.
hunk ./compiler/typecheck/Inst.lhs 1132
-                     False -> best_both 
+                     True -> best_both 
+                     False -> (best_possible, [])
+
   ; traceTc (text "MATT: DONE: " <+> (ppr final))
 	; case final of {
 	    ([(ispec, inst_tys)], []) 
}
[Use mutual recursion between applyContextConstraints, lookupPred to lookup context predicates
matt@softmechanics.net**20100319214527
 Ignore-this: 9ad83e7df5edc404b5dfd473969cff6a
] {
hunk ./compiler/typecheck/Inst.lhs 896
   do ms' <- filterM matchesContext ms
      return (bestInstMatches ms', us)
   where
-    matchesContext (match_inst, _) = 
+    matchesContext (match_inst, match_tvs) = 
       do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
          traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
hunk ./compiler/typecheck/Inst.lhs 899
-         bools <- mapM matchesPred theta
+         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
+         bools <- mapM matchesPredInst predInsts
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
             (Instance { is_tvs = tpl_tvs, is_tys = tpl_tys }) = match_inst
hunk ./compiler/typecheck/Inst.lhs 907
             (Just subst) = tcMatchTys tpl_tvs tpl_tys tys
             theta' = map (substPred subst) theta
 
-            matchesPred pred@(ClassP _ _) =
-              do let (ClassP predC predTys) = substPred subst pred
-                 let lookup = lookupInstEnv ies predC predTys 
-                 traceTc (text "MATT: matchesPred matches" <+> (ppr lookup))
-                 res <- applyContextConstraints inst availP ies predTys lookup
-                 traceTc (text "MATT: matchesPred constrained matches" <+> (ppr res))
-                 case res of
-                   ([x],_) -> instMatchAvailP availP inst x
-                   _       -> return False 
-            matchesPred _ = return False
+            matchesPredInst predInst =
+              do res <- lookupPred False availP predInst
+                 return $ isJust res
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
 matchInst (Dict {tci_pred=pred, tci_loc=loc}) (dfun_id, mb_inst_tys) = do
}
[New ContextConstraints extension flag
matt@softmechanics.net**20100321182444
 Ignore-this: 3c93280d70b18e47953a315364d000ed
 
 Removed short-circuit logic to always accept a single matched element as properly constrained without checking.  
 Finally added ContextConstraints extension flag.  
 Added param to propagate force flag throughout applyContextConstraints/lookupPred loop.
 Made ContextConstraints always ignore unified instances.
 
] {
hunk ./compiler/main/DynFlags.hs 194
    | Opt_OverlappingInstances
    | Opt_UndecidableInstances
    | Opt_IncoherentInstances
+   | Opt_ContextConstraints
    | Opt_MonomorphismRestriction
    | Opt_MonoPatBinds
    | Opt_MonoLocalBinds
hunk ./compiler/main/DynFlags.hs 1639
   ( "FunctionalDependencies",           Opt_FunctionalDependencies, const Supported ),
   ( "GeneralizedNewtypeDeriving",       Opt_GeneralizedNewtypeDeriving, const Supported ),
   ( "OverlappingInstances",             Opt_OverlappingInstances, const Supported ),
+  ( "ContextConstraints",               Opt_ContextConstraints, const Supported ),
   ( "UndecidableInstances",             Opt_UndecidableInstances, const Supported ),
   ( "IncoherentInstances",              Opt_IncoherentInstances, const Supported ),
   ( "PackageImports",                   Opt_PackageImports, const Supported ),
hunk ./compiler/typecheck/Inst.lhs 756
 		-- OK, now extend the envt
 	; return (extendInstEnv home_ie ispec') }
 
+contextConstraintsEnabled :: TcM Bool
+contextConstraintsEnabled 
+  = do { dflags <- getDOpts
+       ; return $ dopt Opt_ContextConstraints dflags
+  }
+  
 getOverlapFlag :: TcM OverlapFlag
 getOverlapFlag 
   = do 	{ dflags <- getDOpts
hunk ./compiler/typecheck/Inst.lhs 890
     }}}}
 
 ---------------
-applyContextConstraints :: Inst -> 
+applyContextConstraints :: Bool ->
+                           Inst -> 
                            (Inst -> TcM Bool) -> 
                            (InstEnv, InstEnv) -> 
                            [Type] -> 
hunk ./compiler/typecheck/Inst.lhs 897
                            ([(Instance,[Either TyVar Type])], [Instance]) -> 
                            IOEnv (Env TcGblEnv TcLclEnv) ([(Instance,[Either TyVar Type])], [Instance])
-applyContextConstraints _ _ _ _ x@([],_) = return x
-applyContextConstraints _ _ _ _ x@([_],_) = return x
-applyContextConstraints inst availP ies tys (ms,us) = 
+applyContextConstraints _ _ _ _ _ x@([],_) = return x
+applyContextConstraints force inst availP ies tys (ms,us) = 
   do ms' <- filterM matchesContext ms
hunk ./compiler/typecheck/Inst.lhs 900
+     traceTc (text "MATT: applyContextCosntraints" <+> 
+         vcat [text "tys" <+> ppr tys,
+               text "pred" <+> ppr inst,
+               text "matches" <+> ppr ms,
+               text "constrained" <+> ppr ms',
+               text "unifs" <+> ppr us])
+  
      return (bestInstMatches ms', us)
   where
     matchesContext (match_inst, match_tvs) = 
hunk ./compiler/typecheck/Inst.lhs 910
-      do traceTc (text "MATT: matchesContext old" <+> (ppr theta))
-         traceTc (text "MATT: matchesContext new" <+> (ppr theta'))
-         (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
+      do (GenInst predInsts _) <- matchInst inst (instanceDFunId match_inst ,match_tvs)
          bools <- mapM matchesPredInst predInsts
          return $ and bools
       where (_, theta, _, _) = instanceHead match_inst
hunk ./compiler/typecheck/Inst.lhs 919
             theta' = map (substPred subst) theta
 
             matchesPredInst predInst =
-              do res <- lookupPred False availP predInst
+              do res <- lookupPred force availP predInst
                  return $ isJust res
 
 matchInst :: Inst -> (DFunId, [Either TyVar TcType]) -> TcM LookupInstResult
hunk ./compiler/typecheck/Inst.lhs 1041
 
 eqVarNamesVar x y = (getName x) == (getName y)
 
-checkAvail _ _ x@([],_) = return x
-checkAvail _ _ x@([_],_) = return x
 checkAvail availP inst (insts,unifs) = 
   do insts' <- filterM (instMatchAvailP availP inst) insts
      return (insts', unifs)
hunk ./compiler/typecheck/Inst.lhs 1115
       True -> traceTc (text "MATT: LOOKUP (FORCE)" <+> ppr pred)
       False -> traceTc (text "MATT: LOOKUP" <+> ppr pred)
   ; traceTc (text "MATT: MATCHES" <+> ppr inst_matches)
-	; constrained <- applyContextConstraints inst availP inst_envs tys insts 
+	; constrained <- applyContextConstraints force inst availP inst_envs tys insts 
   ; traceTc (text "MATT: CONSTRAINED" <+> ppr constrained)
   ; avail_insts <- checkAvail availP inst insts
   ; traceTc (text "MATT: AVAIL INSTS" <+> (ppr avail_insts))
hunk ./compiler/typecheck/Inst.lhs 1121
   ; let best_avail = (\(x,y) -> (bestInstMatches x, y)) avail_insts
   ; traceTc (text "MATT: BEST AVAIL INSTS" <+> (ppr best_avail))
-	; avail_insts' <- applyContextConstraints inst availP inst_envs tys avail_insts
-  ; traceTc (text "MATT: CONSTRAINED AVAIL INSTS" <+> (ppr avail_insts'))
   ; let both_dupes = (\(x1,y1) (x2,y2) -> ((x1++x2),y1++y2)) avail_insts constrained
   ; traceTc (text "MATT: BOTH WORLDS WITH DUPES" <+> (ppr both_dupes))
   ; let both = (\(x1,y1) (x2,y2) -> (removeDuplicates (x1++x2), (y1++y2))) avail_insts constrained
hunk ./compiler/typecheck/Inst.lhs 1130
   ; let (best_matches, _) = best_both
   ; let best_possible = filter (flip isMostSpecificContext inst_matches) best_matches
   ; traceTc (text "MATT: BEST POSSIBLE" <+> (ppr best_possible))
-  ; let final = case force of
-                     -- time to decide. pick the best match(es).
-                     -- deciding too early.
-                     True -> best_both 
-                     False -> (best_possible, [])
+  ; enabled <- contextConstraintsEnabled
+  ; let final = case enabled of
+                      False -> insts
+                      True -> case force of
+                                  -- time to decide. pick the best match(es).
+                                  True -> (fst best_both, [])
+
+                                  -- still have time to see if we get a better match.
+                                  -- if there is no better match, can decide now
+                                  False -> (best_possible, []) 
 
hunk ./compiler/typecheck/Inst.lhs 1141
+  ; case force of
+      True -> traceTc (text "MATT: LOOKUP DONE (FORCE)" <+> 
+                  vcat [text "pred" <+> ppr pred,
+                        text "final" <+> ppr final])
+      False -> traceTc (text "MATT: LOOKUP DONE" <+> 
+                  vcat [text "pred" <+> ppr pred,
+                        text "final" <+> ppr final])
   ; traceTc (text "MATT: DONE: " <+> (ppr final))
 	; case final of {
 	    ([(ispec, inst_tys)], []) 
hunk ./compiler/typecheck/TcSimplify.lhs 1177
 
 		; if null irreds || not improved then
         do {
-            ; traceTc (text "MATT: checkLoop exiting")
+            ; traceTc (text "MATT: checkLoop exiting" <+>
+                 vcat [text "binds" <+> ppr binds,
+                       text "irreds" <+> ppr irreds])
 	 	        ; return (irreds, binds) }
 		  else do
 	
hunk ./compiler/typecheck/TcSimplify.lhs 2231
 	-- Works well for literals (1::Int) and constant dictionaries (d::Num Int)
 	-- Don't bother for implication constraints, which take real work
     try_simple do_this_otherwise
-      = do { res <- lookupSimpleInst force (return . isJust . findAvail avails) wanted
+      = do { res <- lookupSimpleInst force (isAvail avails) wanted
 	   ; case res of
 	        GenInst [] rhs -> addWanted AddSCs avails wanted rhs []
 	        _              -> do_this_otherwise avails wanted }
hunk ./compiler/typecheck/TcSimplify.lhs 2323
 %************************************************************************
 
 \begin{code}
+isAvail :: Avails -> Inst -> TcM Bool
+isAvail avails inst 
+  = do traceTc (text "MATT: isAvail" <+> 
+          vcat [text "inst" <+> (ppr inst)
+               ,text "avails" <+> ppr avails
+               ])
+       traceTc (text "MATT: elemAvails" <+> (ppr $ elemAvails inst avails))
+       let res = findAvail avails inst
+       case res of 
+            Just how -> 
+              do traceTc (text "MATT: isAvail how" <+> (ppr how))
+                 return True
+            Nothing -> 
+              do traceTc (text "MATT: not avail")
+                 return False
+
+
 ---------------------------------------------
 reduceInst :: Bool -> RedEnv -> Avails -> Inst -> TcM (Avails, LookupInstResult)
 reduceInst force _ avails other_inst
hunk ./compiler/typecheck/TcSimplify.lhs 2343
-  = do	{ result <- lookupSimpleInst force (return . isJust . findAvail avails) other_inst
+  = do	{ result <- lookupSimpleInst force (isAvail avails) other_inst
 	; return (avails, result) }
 \end{code}
 
}

Context:

[UNDO: slight improvement to scavenging ...
Simon Marlow <marlowsd@gmail.com>**20100319153413
 Ignore-this: f0ab581c07361f7b57eae02dd6ec893c
 
 Accidnetally pushed this patch which, while it validates, isn't
 correct.
 
 rolling back:
 
 Fri Mar 19 11:21:27 GMT 2010  Simon Marlow <marlowsd@gmail.com>
   * slight improvement to scavenging of update frames when a collision has occurred
 
     M ./rts/sm/Scav.c -19 +15
] 
[slight improvement to scavenging of update frames when a collision has occurred
Simon Marlow <marlowsd@gmail.com>**20100319112127
 Ignore-this: 6de2bb9614978975f17764a0f259d9bf
] 
[Don't install the utf8-string package
Ian Lynagh <igloo@earth.li>**20100317212709] 
[Don't use -Bsymbolic when linking the RTS
Ian Lynagh <igloo@earth.li>**20100316233357
 This makes the RTS hooks work when doing dynamic linking
] 
[Fix Trac #3920: Template Haskell kinds
simonpj@microsoft.com**20100317123519
 Ignore-this: 426cac7920446e04f3cc30bd1d9f76e2
 
 Fix two places where we were doing foldl instead of foldr
 after decomposing a Kind.  Strange that the same bug appears
 in two quite different places!
] 
[copy_tag_nolock(): fix write ordering and add a write_barrier()
Simon Marlow <marlowsd@gmail.com>**20100316143103
 Ignore-this: ab7ca42904f59a0381ca24f3eb38d314
 
 Fixes a rare crash in the parallel GC.
 
 If we copy a closure non-atomically during GC, as we do for all
 immutable values, then before writing the forwarding pointer we better
 make sure that the closure itself is visible to other threads that
 might follow the forwarding pointer.  I imagine this doesn't happen
 very often, but I just found one case of it: in scavenge_stack, the
 RET_FUN case, after evacuating ret_fun->fun we then follow it and look
 up the info pointer.
] 
[Add sliceP mapping to vectoriser builtins
benl@ouroborus.net**20100316060517
 Ignore-this: 54c3cafff584006b6fbfd98124330aa3
] 
[Comments only
benl@ouroborus.net**20100311064518
 Ignore-this: d7dc718cc437d62aa5b1b673059a9b22
] 
[TAG 2010-03-16
Ian Lynagh <igloo@earth.li>**20100316005137
 Ignore-this: 234e3bc29e2f26cc59d7b03d780cc352
] 
[When saying RTS options are disabled, also say how to enable them
Ian Lynagh <igloo@earth.li>**20100315173541] 
[Fix profiling build following removal of specific STM object types
Simon Marlow <marlowsd@gmail.com>**20100315093256
 Ignore-this: b04fd7f984cc0cc38bcf291e400489fd
] 
[When compiling with GHC >= 6.13, use -rtsopts
Ian Lynagh <igloo@earth.li>**20100314172018] 
[Document the new RTS linker flags
Ian Lynagh <igloo@earth.li>**20100314140847] 
[Don't enable RTS options by default
Ian Lynagh <igloo@earth.li>**20100314133648] 
[Add a -with-rtsopts link-time flag
Ian Lynagh <igloo@earth.li>**20100313231342
 You can now link with
     -with-rtsopts="-H128m -K1m"
] 
[Rename a variable
Ian Lynagh <igloo@earth.li>**20100313224852] 
[Add a link-time flag to en/disable the RTS options
Ian Lynagh <igloo@earth.li>**20100313154555
 If RTS options are disabled then:
 * The ghc_rts_opts C code variable is processed as normal
 * The GHCRTS environment variable is ignored and, if it is defined, a
   warning is emitted
 * The +RTS flag gives an error and terminates the program
] 
[Fix a couple of bugs in the throwTo handling, exposed by conc016(threaded2)
Simon Marlow <marlowsd@gmail.com>**20100311123705
 Ignore-this: 80110295e50fcb71d4137c60c2451acd
] 
[Use message-passing to implement throwTo in the RTS
Simon Marlow <marlowsd@gmail.com>**20100311095744
 Ignore-this: 2aeec25282b7a7dfe1132573a8170e2a
 
 This replaces some complicated locking schemes with message-passing
 in the implementation of throwTo. The benefits are
 
  - previously it was impossible to guarantee that a throwTo from
    a thread running on one CPU to a thread running on another CPU
    would be noticed, and we had to rely on the GC to pick up these
    forgotten exceptions. This no longer happens.
 
  - the locking regime is simpler (though the code is about the same
    size)
 
  - threads can be unblocked from a blocked_exceptions queue without
    having to traverse the whole queue now.  It's a rare case, but
    replaces an O(n) operation with an O(1).
 
  - generally we move in the direction of sharing less between
    Capabilities (aka HECs), which will become important with other
    changes we have planned.
 
 Also in this patch I replaced several STM-specific closure types with
 a generic MUT_PRIM closure type, which allowed a lot of code in the GC
 and other places to go away, hence the line-count reduction.  The
 message-passing changes resulted in about a net zero line-count
 difference.
 
] 
[fix bug in discardTasksExcept() that broke forkProcess
Simon Marlow <marlowsd@gmail.com>**20100311093632
 Ignore-this: a38d49b177c4f14ca15a50702c41ae9c
] 
[disable a false assertion, add a comment to explain why
Simon Marlow <marlowsd@gmail.com>**20091123110416
 Ignore-this: 30f45e1cae917259248a2253630e2871
] 
[Fix Trac #1954: newtype deriving caused 'defined but not used' error
simonpj@microsoft.com**20100309173555
 Ignore-this: d403d3c8ae585f604c139d42d43270d
 
 We were getting a bogus claim that a newtype "data constructor" was
 unused.  The fix is easy, although I had to add a field to the constructor
 TcEnv.NewTypeDerived
 
 See Note [Newtype deriving and unused constructors] in TcDeriv
] 
[Rule binders shouldn't have IdInfo
simonpj@microsoft.com**20100309173327
 Ignore-this: 4f788da0258235cc872a4645de0f969e
 
 While I was looking at the rule binders generated in DsBinds for specialise pragmas,
 I also looked at Specialise.  It too was "cloning" the dictionary binders including
 their IdInfo. In this case they should not have any, but its seems better to make
 them completely fresh rather than substitute in existing (albeit non-existent) IdInfo.
] 
[Add comment
simonpj@microsoft.com**20100309173120
 Ignore-this: c04217e40c2eade3e2b28d7919e11de6
] 
[Rule binders shouldn't have DFun pragmas
simonpj@microsoft.com**20100309173100
 Ignore-this: 3298919f2fc8502e367113326f0848
 
 When DsBinds deals with a SPECIALISE pragma, it makes up the binders
 for a RULE. These binders should be very vanilla: no IdInfo of any sort.
 But the way it was before they could have DFun pragmas, which led to
 Bad Joss downstream.  (Actually to cause a downstream *error* was itself
 a bug, which I've fixed, but it's clearly wrong for them to be DFuns!)
] 
[A bug in isClosedUnfolding
simonpj@microsoft.com**20100309172842
 Ignore-this: e030b521cd58f0bfa52c56dd56f12fb5
 
 isClosedUnfolding should say False for DFUnUnfolding!
] 
[Comments only
simonpj@microsoft.com**20100309172814
 Ignore-this: 426455ef147c0b3640ce22ec6c74d8dd
] 
[Comments and type signatures only
simonpj@microsoft.com**20100309172756
 Ignore-this: c31538dd34b35a947a95d2b7258eb3aa
] 
[Comments only
simonpj@microsoft.com**20100309172743
 Ignore-this: 3679f154d68dbb48076d9f5b9b9b7712
] 
[Tidy up pretty-printing of InlinePragma
simonpj@microsoft.com**20100309172730
 Ignore-this: aa75135296ba4de96a704dd41b1ff4d0
 
 We were getting "INLINEALWAYS" printed out here and there.
 Now there are always brackets around the activation, thus "INLINE[ALWAYS]"
] 
[Split part of the Task struct into a separate struct InCall
Simon Marlow <marlowsd@gmail.com>**20100309143111
 Ignore-this: 5dc47acc7b8180ff49fab14de64c99c4
 
 The idea is that this leaves Tasks and OSThread in one-to-one
 correspondence.  The part of a Task that represents a call into
 Haskell from C is split into a separate struct InCall, pointed to by
 the Task and the TSO bound to it.  A given OSThread/Task thus always
 uses the same mutex and condition variable, rather than getting a new
 one for each callback.  Conceptually it is simpler, although there are
 more types and indirections in a few places now.
 
 This improves callback performance by removing some of the locks that
 we had to take when making in-calls.  Now we also keep the current Task
 in a thread-local variable if supported by the OS and gcc (currently
 only Linux).
] 
[add a note
Simon Marlow <marlowsd@gmail.com>**20100309133721
 Ignore-this: e25f24904066dfcdc42a289a830ff67a
] 
[Fix a rare deadlock when the IO manager thread is slow to start up
Simon Marlow <marlowsd@gmail.com>**20100309095831
 Ignore-this: dc2377d587ac681b213fc3b26831958e
 This fixes occasional failures of ffi002(threaded1) on a loaded
 machine.
] 
[When BUILD_DOCBOOK_HTML is NO, keep the rules, just omit the target
simonpj@microsoft.com**20100305173004
 Ignore-this: bbef93db58c56b62ccff0f21bf6fc57f
 
   (and similarly for PS and PDF)
 
 The previous setup nuked the rules for making the documentation when
 BUILD_DOCBOOK_HTML=NO.  This meant that "make html" didn't work.
 
 There isn't any reason to nuke the rules (so far as Simon and I know).
] 
[Fix Trac #3736: do not preInlineUnconditionally with INLINE
simonpj@microsoft.com**20100305172759
 Ignore-this: 29ea0f14333604e5e21eeef95cc46d9e
 
 preInlineUnconditionally was, in effect, nuking an INLINE pragma, with
 very bad effect on runtime in this program.  Fortunately the fix is
 very simple.
 
 See Note [InlineRule and preInlineUnconditionally] in SimplUtils.
] 
[Comments only
simonpj@microsoft.com**20100304125930
 Ignore-this: 79ef68388f9b3b4b25bb7744a69e511e
] 
[Comments only
simonpj@microsoft.com**20100304125402
 Ignore-this: 2c0006e7d26fd7c1f6a89d029eb0e23b
] 
[Refactor part of the renamer to fix Trac #3901
simonpj@microsoft.com**20100304125337
 Ignore-this: 345833048844421020d0a178acee54d9
 
 This one was bigger than I anticipated!  The problem was that were
 were gathering the binders from a pattern before renaming -- but with
 record wild-cards we don't know what variables are bound by C {..}
 until after the renamer has filled in the "..".
 
 So this patch does the following
 
 * Change all the collect-X-Binders functions in HsUtils so that
   they expect to only be called *after* renaming.  That means they
   don't need to return [Located id] but just [id].  Which turned out
   to be a very worthwhile simplification all by itself.
 
 * Refactor the renamer, and in ptic RnExpr.rnStmt, so that it
   doesn't need to use collectLStmtsBinders on pre-renamed Stmts.
 
 * This in turn required me to understand how GroupStmt and
   TransformStmts were renamed.  Quite fiddly. I rewrote most of it;
   result is much shorter.
 
 * In doing so I flattened HsExpr.GroupByClause into its parent
   GroupStmt, with trivial knock-on effects in other files.
 
 Blargh.
] 
[Minor refactoring of placeHolderPunRhs
simonpj@microsoft.com**20100304124113
 Ignore-this: 717a7b412946f4eda5ec56aa72459bd4
] 
[Make `mkFunTy` associate to the right, as it should
simonpj@microsoft.com**20100304124029
 Ignore-this: 3df1f02c28272c5da37836161f8538a9
] 
[Add fmapMaybeM and fmapEitherM
simonpj@microsoft.com**20100304124004
 Ignore-this: ba780d5d14a6766378502e58c4d7ae0f
] 
[Comments only
simonpj@microsoft.com**20100304123939
 Ignore-this: b2c75384418e49bfeb847c089b8639e2
] 
[Two things to do with -dsuppress-uniques
simonpj@microsoft.com**20100304123822
 Ignore-this: ebe626cb50230f6d2da165dea7f4a1b3
 
 a) Even with -dsuppress-uniques, don't suppress them when outputing
    code, else the assembler falls over bleating
 
 b) Do suppress uniques in names generated by TH.  It's a bit grungy
    to do this: see Note [Suppressing uniques in OccNames].  But
    it's only needed for test de-wobblification so the grunge isn't
    really important.
] 
[fix the Windows build some more
Simon Marlow <marlowsd@gmail.com>**20100304092119
 Ignore-this: b6f0ef572f6c8f263a02bc802c9ff328
] 
[Add comments to darcs-all and packages
simonpj@microsoft.com**20100303215948
 Ignore-this: c84876f3bdf976a4d8716451c3ea49c7
] 
[Add the implicit 'import Prelude' in getImports
Simon Marlow <marlowsd@gmail.com>**20100303112242
 Ignore-this: 6c5e7ed21c29e9ffb362db63f8c69e2f
 This makes things more consistent, and avoids a strange "Prelude is
 not loaded" error when there is a Prelude.hs on the search path.
] 
[fix Windows build
Simon Marlow <marlowsd@gmail.com>**20100302144719
 Ignore-this: fac21f11a8bd010f7e3cb242b908146f
] 
[sdist: Haddock.Interface.{Lex,Parse} moved to Haddock.{Lex,Parse}
Simon Marlow <marlowsd@gmail.com>**20100302094338
 Ignore-this: beeb4887522e051d178774af20c6a7e8
] 
[Add handling for | to the transitional alternative layout rule
Ian Lynagh <igloo@earth.li>**20100302205815] 
[Tweak alternative layout rule
Ian Lynagh <igloo@earth.li>**20100302205105
 Now not only is if/then a bracketting pair, but then/else is too
] 
[Add transitional rules for the alternative layout rule
Ian Lynagh <igloo@earth.li>**20100302202035
 If enabled, these accept more layout, but give warnings
] 
[Fix the alternative layout rule to handle explicit let/in
Ian Lynagh <igloo@earth.li>**20100302165119
 It used to break on
     let {x = 'a'} in x
 as the 'in' token would keep closing contexts looking for an implicit
 'let' layout.
] 
[expand comments for #2578 fix
Simon Marlow <marlowsd@gmail.com>**20100301095525
 Ignore-this: 720ce0cafd155bfdef0516900568276
] 
[a faster appendFS
ich@christoph-bauer.net**20100227211659
 Ignore-this: e0e45620b3a901291621e34953384a27
] 
[Implement a smart constructor mkUnsafeCoercion, and use it
simonpj@microsoft.com**20100301111744
 Ignore-this: 88906e30bf14b025ffa2fa9a4355e436
 
 This just ensures that an unsafe coercion is as localised as possible.
 For example, instead of
     UnsafeCo (Int -> t1) (Int -> t2)
 use 
     Int -> UnsafeCo t1 t2
] 
[Suggest -XGeneralizedNewtypeDeriving (fix Trac #3888)
simonpj@microsoft.com**20100301111555
 Ignore-this: 9edbf63ef5506aba2fafb83c1c365d4b
 
 If we can't derive a type, but it's a reasonable possibility that
 newtype deriving would do the job, suggest it. 
 
 A little refactoring too, moving non_iso_class to top level,
 and putting it with std_class_via_iso.
] 
[Tidy up AnyTyCon stuff
simonpj@microsoft.com**20100301111401
 Ignore-this: 6ea0a0c793f9c6b812bc5c6fb0d392a1
 
 If we find ourselves making up an AnyTyCon of kind '??', say, 
 then default it to liftedTypeKind.  And similarly for any sub-kind
 of LiftedTypeKind.
 
 This is just a tidy-up.
] 
[Fix pretty-printing of IfaceAnyTc (fixes Trac #3883)
simonpj@microsoft.com**20100301111040
 Ignore-this: 6a059d5f9b895a0b709837c2584742be
 
 The panic message in ifaceTyConName on IfaceAnyTc 
 called the pretty-printer, called ifaceTyConName again,
 which caused an infinite regress.  Stupid.
 
 See 
  * Note [The Name of an IfaceAnyTc], and 
  * The Outputable instance for IfaceTyCon
] 
[Omit unnecessary parens when pretty-printing IfaceExpr
simonpj@microsoft.com**20100301110748
 Ignore-this: ccb00190892a4b2ff62c45d583018a70
] 
[Comments only
simonpj@microsoft.com**20100225174112
 Ignore-this: d0fc0ca9dbeca3c17b11733d6e8cb022
] 
[Add comment
simonpj@microsoft.com**20100225174048
 Ignore-this: 9e93edacc2424ca0e8a0f0a7d1992736
] 
[Change pretty printing of InlinePrag slightly
simonpj@microsoft.com**20100225174028
 Ignore-this: 7348baeb43926d3c746a39cb4e67f1a3
] 
[Add -no-auto-link-packages docs to the user guide; fixes trac #3759
Ian Lynagh <igloo@earth.li>**20100228191837] 
[Whitespace only in docs/users_guide/packages.xml
Ian Lynagh <igloo@earth.li>**20100228182945] 
[Add a LICENSE file to libraries/bin-package-db
Ian Lynagh <igloo@earth.li>**20100227205626
 Silences a (harmless) error from tar when making bindists
] 
[Have separate rules to generate tags and TAGS
Ian Lynagh <igloo@earth.li>**20100227202517
 This works around the two filenames being the same on case-insensitive
 file systems.
] 
[Fix trac #2578
Ian Lynagh <igloo@earth.li>**20100227173951
 We define empty datatypes as not being enumerations, which means the
 empty blocks aren't generated.
] 
[Fix the build with GHC < 6.12
Ian Lynagh <igloo@earth.li>**20100226223931] 
[update the docs to reflect changes in the tracing flags
Simon Marlow <marlowsd@gmail.com>**20100226111205
 Ignore-this: 3396e95f52abbb4a022391ca8709085b
] 
[Tweak the tracing flags slightly, and clean up error handling and diagnostics
Simon Marlow <marlowsd@gmail.com>**20100226110608
 Ignore-this: c227b6b8d65c06f299c5588c84e0eef9
 
 Tracing flags are now:
 
    -l[flags]  Log events in binary format to the file <program>.eventlog
    -v[flags]  Log events to stderr
               where [flags] can contain:
                  s    scheduler events
                  t    add time stamps (only useful with -v)
 
 and there are more helpful error messages when using flags that are
 only available in particular variants of the RTS:
 
  the flag -v requires the program to be built with -debug
  the flag -Ds requires the program to be built with -debug
  the flag -p requires the program to be built with -prof
  the flag -N requires the program to be built with -threaded
  the flag -v requires the program to be built with -debug
 
 Also, I fixed the crash reported in #3874, with +RTS -ls -v.
] 
[Fix crash when using printf format specifiers in traceEvent (#3874)
Simon Marlow <marlowsd@gmail.com>**20100226093215
 Ignore-this: d21701cec90e9f5f2d9e7148490b9ced
] 
[hack to make the docs build again in a lndir build tree (see comments)
Simon Marlow <marlowsd@gmail.com>**20100225131616
 Ignore-this: 4d9a66364222b51a750d33fbce5f8f36
] 
[Force encoding to UTF-8 when writing individual .conf files
Simon Marlow <marlowsd@gmail.com>**20100224152519
 Ignore-this: 8707c55c74108570cd9d60a4cb43c561
] 
[Fix build for non-x86 arches again.
Ben.Lippmeier@anu.edu.au**20100222075144] 
[Fix the link to the ghc docs in libraries/prologue.txt
Ian Lynagh <igloo@earth.li>**20100223181644] 
[Fix more library links in the user guide
Ian Lynagh <igloo@earth.li>**20100223164551] 
[Fix the links to the base docs from the user guide
Ian Lynagh <igloo@earth.li>**20100223150522] 
[Remove old, unused release notes
Ian Lynagh <igloo@earth.li>**20100223150327] 
[Fix #3875: Crash in parallel GC, wrong pointer was being tested.
Ben.Lippmeier@anu.edu.au**20100222031627] 
[Add utils/ghctags/ghc.mk
Ian Lynagh <igloo@earth.li>**20100221185200] 
[Make "make tags" work in the new build system
Ian Lynagh <igloo@earth.li>**20100221164432] 
[Remove the old hstags util
Ian Lynagh <igloo@earth.li>**20100220235909] 
[Check for suitable versions of make in bindists; fixes trac #3860
Ian Lynagh <igloo@earth.li>**20100220211157
 We already had a check in configure of the actual build. This patch
 adds it to the configure of the bindists too.
] 
[Fix build on Windows
Ian Lynagh <igloo@earth.li>**20100219134222] 
[Use the shared C wrapper code in ghci.c too
Ian Lynagh <igloo@earth.li>**20100218171716] 
[Refactor gcc.c, pulling out the reusable code
Ian Lynagh <igloo@earth.li>**20100218170931] 
[Fix a recompilation checking bug when a package dependency changes
Simon Marlow <marlowsd@gmail.com>**20100217133250
 Ignore-this: afea726c69145f08ea66053230a85bff
 
 We weren't forcing enough recompilationg when package dependencies
 changed, with the result that bumping a package version could lead to
 linking failures or other problems later.
 
 The problem/solutation are described on the wiki:
 
 http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance#Packageversionchanges
] 
[darcs-all --extra get: gets a few extra packages
Simon Marlow <marlowsd@gmail.com>**20100217104634
 Ignore-this: 9a025b387e5a09b4cde7ac5a52c95268
 currently deepseq, parallel, stm.
] 
[Allow extra packages to be added to the build, by setting $(EXTRA_PACKAGES)
Simon Marlow <marlowsd@gmail.com>**20100217103134
 Ignore-this: 434abc03d82316e8248a76ae23f673b8
] 
[Beef up cmmMiniInline a tiny bit
Simon Marlow <marlowsd@gmail.com>**20100216150506
 Ignore-this: 94513491cd20d21e3a6b0b6f9c579ca4
 Allow a temporary assignment to be pushed past an assignment to a
 global if the global is not mentioned in the rhs of the assignment we
 are inlining.
 
 This fixes up some bad code.  We should make sure we're doing
 something equivalent in the new backend in due course.
] 
[Write the binary cache file atomically
Simon Marlow <marlowsd@gmail.com>**20100216134841
 Ignore-this: 8b1a26beb04dbfcb15786461c8f35f12
 Should fix an occasional build error of the form 
  ghc-pkg: too few bytes. Failed reading at byte position 8
] 
[disable a false assertion, with a comment to explain why
Simon Marlow <marlowsd@gmail.com>**20100216123544
 Ignore-this: 2be07076eed3c203543025e61ec69838
] 
[Fix a bug that can lead to noDuplicate# not working sometimes.
Simon Marlow <marlowsd@gmail.com>**20100216123411
 Ignore-this: 1ff0b235d915ca4d0531df6326828901
 
 The symptom is that under some rare conditions when running in
 parallel, an unsafePerformIO or unsafeInterleaveIO computation might
 be duplicated, so e.g. lazy I/O might give the wrong answer (the
 stream might appear to have duplicate parts or parts missing).
 
 I have a program that demonstrates it -N3 or more, some lazy I/O, and
 a lot of shared mutable state.  See the comment with stg_noDuplicatezh
 in PrimOps.cmm that explains the problem and the fix.  This took me
 about a day to find :-(
] 
[Represent the free register set using Word64 on x86-64 (fixes ffi009)
Simon Marlow <marlowsd@gmail.com>**20100215130102
 Ignore-this: b75fe873a9d32c56dc43b2f30d3382fb
 Following recent changes to the numbering of registers, we overflowed
 Word32 on x86-64, with the result that xmm8 and later we not being
 allocated.
] 
[fix lost context switches in GHCi (fixes test 3429(ghci))
Simon Marlow <marlowsd@gmail.com>**20100215093205
 Ignore-this: 5a2cf725a83da1067a299fccc63aeb9f
] 
[Fix build for non-x86 architectures
Ben.Lippmeier@anu.edu.au**20100215014719] 
[Add comments about the ForceSpecConstr mechanism
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20100215030103
 Ignore-this: 8f0c3c4e65ce22b04e511d51d7795896
] 
[Spot ForceSpecConstr arguments in polymorphic loops
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20100215025308
 Ignore-this: c3160d51fdb44bfaa600491423257d0b
] 
[Don't rely on tar supporting -z; trac #3841
Ian Lynagh <igloo@earth.li>**20100214220450] 
[don't constant fold division that would result in negative zero (#3676)
Simon Marlow <marlowsd@gmail.com>**20100211131543
 Ignore-this: 9ccba7389ec0de33ec7f376ae39f34fb
] 
[Improve error dump in TcEnv
simonpj@microsoft.com**20100210145210
 Ignore-this: 97c0390699f8ec70e8904e86730a1d5c
] 
[Keep track of explicit kinding in HsTyVarBndr; plus fix Trac #3845
simonpj@microsoft.com**20100210145155
 Ignore-this: ff7e42280909d340dd3d043d89c702ba
 
 To print HsTypes correctly we should remember whether the Kind on
 a HsTyVarBndr came from type inference, or was put there by the
 user.  See Note [Printing KindedTyVars] in HsTypes.  So instead of
 changing a UserTyVar to a KindedTyVar during kind checking, we
 simply add a PostTcKind to the UserTyVar.
 
 The change was provoked by Trac #3830, although other changes
 mean that #3830 gets a diferent and better error message now.
 So this patch is simply doing the Right Thing for the future.
 
 This patch also fixes Trac #3845, which was caused by a *type splice*
 not remembering the free *term variables* mentioned in it.  Result
 was that we build a 'let' when it should have been 'letrec'.
 Hence a new FreeVars field in HsSpliceTy.
 
 While I was at it, I got rid of HsSpliceTyOut and use a PostTcKind
 on HsSpliceTy instead, just like on the UserTyVar.
] 
[Documentation for changes to Template Haskell and quasi-quotation
simonpj@microsoft.com**20100210114213
 Ignore-this: 24684cbf43c50eecc36f3e98882df1e4
] 
[Remove redundant import
simonpj@microsoft.com**20100208165756
 Ignore-this: f1cc1331507452422e0db8f8f5f80ad
] 
[Stop fruitless ANF-ing
simonpj@microsoft.com**20100210094733
 Ignore-this: 1c1251c462f3fd8ae7665a1869c0e18a
 
 The simplifier is taking more iterations than it should, because we
 were fruitlessly ANF-ing a top-level declaration of form
 
    x = Ptr "foo"#
 
 to get
  
    x = let v = "foo"# in Ptr v
 
 and then inlining v again.  This patch makes Simplify.makeTrivial 
 top-level aware, so that it doesn't ANF if it's going to be undone.
] 
[Comments only
simonpj@microsoft.com**20100210094537
 Ignore-this: dab7a4e7fad9f424d3ab2590c3eeef3f
] 
[Simplify syntax for quasi-quotation
simonpj@microsoft.com**20100210094419
 Ignore-this: ffc1e483942a7506d4a541300908bcd
 
 After some discussion we decided to make a quasi-quote look like
 
    [pads| ...blah... |]
 
 rather than
 
    [$pads| ...blah... |]
 
 as before. The new syntax is quieter, although it does not signal
 quite as clearly that there is a splice going on.
] 
[Several TH/quasiquote changes
simonpj@microsoft.com**20100210093910
 Ignore-this: f12d3703f10a377e57f1af854905c6aa
 
 a) Added quasi-quote forms for
       declarations
       types
    e.g.   f :: [$qq| ... |]
 
 b) Allow Template Haskell pattern quotes (but not splices)
    e.g.  f x = [p| Int -> $x |]
 
 c) Improve pretty-printing for HsPat to remove superfluous
    parens.  (This isn't TH related really, but it affects
    some of the same code.)
 
 
 A consequence of (a) is that when gathering and grouping declarations
 in RnSource.findSplice, we must expand quasiquotes as we do so.
 Otherwise it's all fairly straightforward.  I did a little bit of
 refactoring in TcSplice.
 
 User-manual changes still to come.
] 
[generate slightly better code for ccall argument-pushing on x86
Simon Marlow <marlowsd@gmail.com>**20100209101114
 Ignore-this: a41b366d7266b8fc31a099308c318597
] 
[--lazy overrides --partial too
Simon Marlow <marlowsd@gmail.com>**20100209093927
 Ignore-this: 5d67c45af67f0122d93965ea9d0cbb12
 At least until we switch to --lazy being the default
] 
[Fix Trac #3850
simonpj@microsoft.com**20100208163751
 Ignore-this: ed77f179dafe3f2d32971364e604e518
 
 This patch simply avoids a needless difference in behaviour from 
 6.10, and one that happens to affect HList. See Note [Stupid theta].
] 
[Fix a bug introduced in the SSE2 support: callClobberedRegs was wrong
Simon Marlow <marlowsd@gmail.com>**20100205112938
 Ignore-this: 4a7989284af27a607aae08f27c222515
] 
[Implement SSE2 floating-point support in the x86 native code generator (#594)
Simon Marlow <marlowsd@gmail.com>**20100204104849
 Ignore-this: 7290454bf6b2f3612b933c4f23e8a471
 
 The new flag -msse2 enables code generation for SSE2 on x86.  It
 results in substantially faster floating-point performance; the main
 reason for doing this was that our x87 code generation is appallingly
 bad, and since we plan to drop -fvia-C soon, we need a way to generate
 half-decent floating-point code.
 
 The catch is that SSE2 is only available on CPUs that support it (P4+,
 AMD K8+).  We'll have to think hard about whether we should enable it
 by default for the libraries we ship.  In the meantime, at least
 -msse2 should be an acceptable replacement for "-fvia-C
 -optc-ffast-math -fexcess-precision".
 
 SSE2 also has the advantage of performing all operations at the
 correct precision, so floating-point results are consistent with other
 platforms.
 
 I also tweaked the x87 code generation a bit while I was here, now
 it's slighlty less bad than before.
] 
[add libraries/binary
Simon Marlow <marlowsd@gmail.com>**20100203135421
 Ignore-this: b9249fd05feb6b29fa7729edcdc2472
] 
[add comment for srt_bitmap field
Simon Marlow <marlowsd@gmail.com>**20100203103431
 Ignore-this: 1b76ed3dceed40c3fc6040c90f577997
] 
[Use bash to run boot-pkgs, the default Solaris shell doesn't support the -ot test flag
benl@cse.unsw.edu.au**20100203030748] 
[Disable -Wcast-align when building the rts
benl@cse.unsw.edu.au**20100203024605
 This flag seems buggy on GCC 4.1.2, which is the only GCC version we 
 have that can bootstrap the SPARC build. We end up with lots of supurious
 warnings of the form "cast increases required alignment of target type".
 Some legitimate warnings can be fixed by adding an intermediate cast to
 (void*), but we get others in rts/sm/GCUtils.c concerning the gct var
 that look innocuous to me. We could enable this again once we deprecate
 support for registerised builds on this arch.
] 
[Stifle warning about printf format strings
benl@cse.unsw.edu.au**20100203023124] 
[Cast to (void*) to stifle warning about signedness
benl@cse.unsw.edu.au**20100203023029] 
[Add missing import sm_mutex, which fixes the -fvia-c build
benl@cse.unsw.edu.au**20100202051451] 
[Fix typo in error message (#3848)
Simon Marlow <marlowsd@gmail.com>**20100130094628
 Ignore-this: f0713035828123805b2a237e8896315b
] 
[Fix Trac #3831: blowup in SpecConstr
simonpj@microsoft.com**20100201002420
 Ignore-this: adbf1e249f472cbc8d2d7cc1f70ae1fd
 
 It turned out that there were two bugs.  First, we were getting an
 exponential number of specialisations when we had a deep nest of
 join points.  See Note [Avoiding exponential blowup]. I fixed this
 by dividing sc_count (in ScEnv) by the number of specialisations
 when recursing.  Crude but effective.
 
 Second, when making specialisations I was looking at the result of
 applying specExpr to the RHS of the function, whereas I should have
 been looking at the original RHS.  See Note [Specialise original
 body].
 
 
 There's a tantalising missed opportunity here, though.  In this
 example (recorded as a test simplCore/should_compile/T3831), each join
 point has *exactly one* call pattern, so we should really just
 specialise for that alone, in which case there's zero code-blow-up.
 In particular, we don't need the *original* RHS at all.  I need to think
 more about how to exploit this.
 
 But the blowup is now limited, so compiling terminfo with -O2 works again.
] 
[Re-read pragmas after preprocessing (#2464, #3674, #3457)
Simon Marlow <marlowsd@gmail.com>**20100129114050
 Ignore-this: 1acf43a0bd924f9cc89f98b291569517
 This was a lot easier than I imagined.
] 
[tweak the totally-bogus arbitrary stack-squeezing heuristic to fix #2797
Simon Marlow <marlowsd@gmail.com>**20100128124454
 Ignore-this: 330f39d1fc17280c6264443cba35538b
 In #2797, a program that ran in constant stack space when compiled
 needed linear stack space when interpreted.  It turned out to be
 nothing more than stack-squeezing not happening.  We have a heuristic
 to avoid stack-squeezing when it would be too expensive (shuffling a
 large amount of memory to save a few words), but in some cases even
 expensive stack-squeezing is necessary to avoid linear stack usage.
 One day we should implement stack chunks, which would make this less
 expensive.
] 
[fix warning on Windows
Simon Marlow <marlowsd@gmail.com>**20100127162954
 Ignore-this: 9aeca7b0d6bfdf758ab9b2004c998b2b
] 
[fix Windows build (GHC.Conc.runHandlers is Unix-only)
Simon Marlow <marlowsd@gmail.com>**20100127145718
 Ignore-this: 9e683bfbc236beb7aa6fc29cddea4e46
] 
[Don't Terminate the ticker thread (#3748)
Simon Marlow <marlowsd@gmail.com>**20100127135430
 Ignore-this: c4834d02397eb3404818142964f296e4
] 
[Win32 yieldThread(): use SwitchToThread() instead of Sleep(0)
Simon Marlow <marlowsd@gmail.com>**20100127133106
 Ignore-this: cbc8c00fd4b7de7d191dae8f21f4f012
] 
[fix warnings
Simon Marlow <marlowsd@gmail.com>**20100127133040
 Ignore-this: 1038f5f85bd3f795ad10380d7b78457f
] 
[catch SIGHUP and SIGTERM and raise an exception (#3656)
Simon Marlow <marlowsd@gmail.com>**20100127140438
 Ignore-this: a6163c4563d67daab632db2ab2cc7155
] 
[define INFINITY and NAN if they don't exist (#2929)
Simon Marlow <marlowsd@gmail.com>**20100127133632
 Ignore-this: 488fa62a65c0d8a2e0b9ca4c6dd844a
] 
[remove suspicious whitespace-only lines
Simon Marlow <marlowsd@gmail.com>**20100127133008
 Ignore-this: dc99b80bca5d9510d651c9afb0cd4fda
] 
[addCoverageTicksToBinds: tolerate a non-existent .hs file (#3803)
Simon Marlow <marlowsd@gmail.com>**20100127113205
 Ignore-this: c65cd3962a1e1bba7b7a5b6ff723dc9c
] 
[avoid using non-standard %zd format specifier (#3804)
Simon Marlow <marlowsd@gmail.com>**20100126163322
 Ignore-this: fc5f69ec8af42138f930177f8c48d3e6
] 
[Fix signal segfaults on Solaris (#3790)
Simon Marlow <marlowsd@gmail.com>**20100126155449] 
[comment-out an incorrect assertion
Simon Marlow <marlowsd@gmail.com>**20100126150103
 Ignore-this: d4dcb06f5c4cbfd826033cd7f7170fc6
] 
[Fix a deadlock, and possibly other problems
Simon Marlow <marlowsd@gmail.com>**20100126150037
 Ignore-this: e461e2a5495850cb0a43544004bbe994
 After a bound thread had completed, its TSO remains in the heap until
 it has been GC'd, although the associated Task is returned to the
 caller where it is freed and possibly re-used.  
 
 The bug was that GC was following the pointer to the Task and updating
 the TSO field, meanwhile the Task had already been recycled (it was
 being used by exitScheduler()). Confusion ensued, leading to a very
 occasional deadlock at shutdown, but in principle it could result in
 other crashes too.
 
 The fix is to remove the link between the TSO and the Task when the
 TSO has completed and the call to schedule() has returned; see
 comments in Schedule.c.
] 
[When acquiring a spinlock, yieldThread() every 1000 spins (#3553, #3758)
Simon Marlow <marlowsd@gmail.com>**20100122164911
 Ignore-this: 2dc6a7affdb5081a4dc649bcac95c31d
 
 This helps when the thread holding the lock has been descheduled,
 which is the main cause of the "last-core slowdown" problem.  With
 this patch, I get much better results with -N8 on an 8-core box,
 although some benchmarks are still worse than with 7 cores.
 
 I also added a yieldThread() into the any_work() loop of the parallel
 GC when it has no work to do. Oddly, this seems to improve performance
 on the parallel GC benchmarks even when all the cores are busy.
 Perhaps it is due to reducing contention on the memory bus.
] 
['store' should be static (#3835)
Simon Marlow <marlowsd@gmail.com>**20100122164834
 Ignore-this: 65fab4644badc58ce284c3ca5c29f88a
] 
[Add some missing getStablePtr()s for CAFs that the RTS refers to
Simon Marlow <marlowsd@gmail.com>**20100122143658
 Ignore-this: 7bf37917d5052a6feb3b8ffeaad0ab4c
 
 A recent patch ("Refactor CoreArity a bit") changed the arity of
 GHC.Conc.runSparks such that it became a CAF, and the RTS was not
 explicitly retaining it, which led to a crash when the CAF got GC'd.
 While fixing this I found a couple of other closures that the RTS
 refers to which weren't getting the correct CAF treatment.
] 
[Remove an out-of-date comment
Ian Lynagh <igloo@earth.li>**20100122130853] 
[fix build on Windows
Simon Marlow <marlowsd@gmail.com>**20100122121016
 Ignore-this: cd690a8eff71ca4f87fe67a41a20f493
] 
[fix warning on Windows
Simon Marlow <marlowsd@gmail.com>**20100122120328
 Ignore-this: 507a91e356a667dcecf8bec621fd2b95
] 
[Fix docs for sizeofByteArray#/sizeofMutableByteArray# (#3800)
Simon Marlow <marlowsd@gmail.com>**20100119103825
 Ignore-this: c5b7c2edb30fb0917ec08e74f26e9b9e
 In 6.14.1 we'll switch these primops to return the exact byte size,
 but for 6.12.2 we need to fix the docs.
] 
[Include regex.h in Linker.c on OS X too
Ian Lynagh <igloo@earth.li>**20100120201958] 
[We no longer need a prototype for __eprintf
Ian Lynagh <igloo@earth.li>**20100120195024
 It looks like it was only needed on OSX, but it has a prototype in
 assert.h which now gets #included.
] 
[Fix build
Ian Lynagh <igloo@earth.li>**20100120163101
 Remove a prototype of a function that wasn't defined
] 
[FIX #2615 (linker scripts in .so files)
howard_b_golden@yahoo.com**20091216185155
 Ignore-this: e470cb78dc7cc9f39cba209e594c6283
 This patch does not apply to Windows. It only applies to systems with
 ELF binaries.
 
 This is a patch to rts/Linker.c to recognize linker scripts in .so
 files and find the real target .so shared library for loading.
] 
[Fix Trac #3813: unused variables in GHCi bindings
simonpj@microsoft.com**20100120094533
 Ignore-this: 22da9bc22ecde0056f7235b3cf86ba8e
 
 In a GHCi stmt we don't want to report unused variables, 
 because we don't know the scope of the binding, eg
 
 	Prelude> x <- blah
 
 Fixing this needed a little more info about the context of the stmt,
 thus the new constructor GhciStmt in the HsStmtContext type.
] 
[Fix Trac #3823, plus warning police in TcRnDriver
simonpj@microsoft.com**20100120094221
 Ignore-this: 8856cf1ab48733180d0cfa800b535317
 
 The immediate reason for this patch is to fix #3823. This was 
 rather easy: all the work was being done but I was returning
 type_env2 rather than type_env3.  
 
 An unused-veriable warning would have shown this up, so I fixed all
 the other warnings in TcRnDriver.  Doing so showed up at least two
 genuine lurking bugs.  Hurrah.
] 
[Change how RTS libraries get installed; fixes trac #3794
Ian Lynagh <igloo@earth.li>**20100119232623] 
[Escape some more $s in makefiles, for consistency
Ian Lynagh <igloo@earth.li>**20100119225533] 
[Escape some $s in makefiles for consistency
Ian Lynagh <igloo@earth.li>**20100119221440] 
[Allow GNU-standard --host, --build, --target configure options (#3637)
Simon Marlow <marlowsd@gmail.com>**20100119102819
 Ignore-this: 3fd7c644658321f97c34e20305e9b458
 Patch contributed by asuffield@suffields.me.uk
] 
[Update some comments about how autoconf/configure works
Ian Lynagh <igloo@earth.li>**20100118145959] 
[Fix a warning message
Ian Lynagh <igloo@earth.li>**20100118142020
 We were printing the wrong value, so getting confusing messages like:
     Function `$wa{v s17LO} [lid]'
         has 2 call pattterns, but the limit is 3
] 
[Teach the alternative layout rule about mdo and rec
Ian Lynagh <igloo@earth.li>**20100116215545] 
[Teach the alternative layout rule about $( ... )
Ian Lynagh <igloo@earth.li>**20100116213941
 It thought the ) needed to close something, but the $( hadn't
 opened anything.
] 
[Fix typo
Ian Lynagh <igloo@earth.li>**20100116134915] 
[Remove declaration of non-existent mark_splim
Simon Marlow <marlowsd@gmail.com>**20091231104241
 Ignore-this: 33ad68a3f12360a51d60df47d748f31e
] 
[fix a comment
Simon Marlow <marlowsd@gmail.com>**20091230150852
 Ignore-this: 776891008d34de6bf1f89d74d516bce0
] 
[remove an unnecessary debug trace, duplicated by a traceSchedEvent
Simon Marlow <marlowsd@gmail.com>**20091230150832
 Ignore-this: 2768ab3555fee6dbe2a0ac2c0349f83d
] 
[hide modules properly with haddock
Simon Marlow <marlowsd@gmail.com>**20100113210311
 Ignore-this: e928241534a934008d050b387cb1cfe4
] 
[fix for HSCOLOUR_SRCS=NO
Simon Marlow <marlowsd@gmail.com>**20100113191555
 Ignore-this: d952b550d8597a4029e674da24cbaef3
] 
[Do some recompilation avoidance in GHC.loadModule
Simon Marlow <marlowsd@gmail.com>**20100112225853
 Ignore-this: d5f04baa437a307544c4a7cf87931e92
 GHC.loadModule compiles a module after it has been parsed and
 typechecked explicity. If we are compiling to object code and there is
 a valid object file already on disk, then we can skip the compilation
 step. This is useful in Haddock, when processing a package that uses
 Template Haskell and hence needs actual compilation, and the package
 has already been compiled.
 
 As usual, the recomp avoidance can be disabled with -fforce-recomp.
] 
[Invoke Haddock directly from the build system, instead of via Cabal
Simon Marlow <marlowsd@gmail.com>**20100112225548
 Ignore-this: 1d30babfb13c2d110f79ce6c98cd2142
 
 Partly this is cleaner as we only have to preprocess the source files
 once, but also it is necessary to avoid Haddock recompiling source
 files when Template Haskell is in use, saving some time in validate
 and fixing a problem whereby when HADDOCK_DOCS=YES, make always
 re-haddocks the DPH packages.  This also needs an additional fix to
 GHC.
 
 HsColour support still uses Cabal, and hence preprocesses the source
 files again. We could move this into the build system too, but there
 is a version dependency that would mean adding extra autoconf stuff.
] 
[refactoring while I try to make sense of the hsc interface
Simon Marlow <marlowsd@gmail.com>**20100104112833
 Ignore-this: 2504fbfa92a7bfa393a62cb40782d288
] 
[Fix running in-place gen_contents_index; trac #3716
Ian Lynagh <igloo@earth.li>**20100108133416
 It was making incorrect URLs due to a shell script error.
] 
[Respect SPECIALISE pragmas even for apparently-non-overloaded things
simonpj@microsoft.com**20100108084547
 Ignore-this: 206abe8175904a9512198f34e8aa81e
 
 This is an implementation matter really (the key word is "apparently"!).  
 See Note [Specialising in no-dict case] in DsBinds.
 
 It showed up when compiling GHC.Float.
] 
[Comment out debug warnings; they are fine
simonpj@microsoft.com**20100108084428
 Ignore-this: 4d0901ca3bd903f07578183cc3b0b69d
] 
[Improve error locations
simonpj@microsoft.com**20100107153234
 Ignore-this: 505f3d32355c68841c3d8118863997b
 
 More on Trac #597
] 
[Spelling error in comment
simonpj@microsoft.com**20100107151127
 Ignore-this: bcc83729352bb1636727207abdd21335
] 
[A little refactoring, plus improve error locations
simonpj@microsoft.com**20100107151113
 Ignore-this: c7da9f3df315a580d3e5ac2b412307ba
 
 Fixes some sub-items of Trac #597
] 
[Clarify error message (Trac #3805)
simonpj@microsoft.com**20100107151002
 Ignore-this: f5300f64a6e01764d1a671c6bfe13704
] 
[Comments only
simonpj@microsoft.com**20100107150939
 Ignore-this: d1760073cbd91798e1e5f2941bfd21aa
] 
[SpecConstr: Remove -fspec-inline-join-points, and add let-binding specialisation
simonpj@microsoft.com**20100106165251
 Ignore-this: afdc78550d4a20f0a41807970e2c9a8b
 
 The -fspec-inline-join-point thing was a gross hack intended to help
 Roman play around, but he's not using it and it was a terribly blunt
 instrument so I've nuked it.  
 
 Instead I've re-instated the let-binding specialiser. 
 See Note [Local let bindings]
] 
[Make SpecConstr more informative output when there are too many specialisations
simonpj@microsoft.com**20100106161026
 Ignore-this: 9526c38858763f2378a5184ed73df32f
 
 It now says something like
 
   SpecConstr
     Function `happyDoAction'
       has 17 call pattterns, but the limit is 3
     Use -fspec-constr-count=n to set the bound
     Use -dppr-debug to see specialisations
 
 Previously it just silently did no specialisation
] 
[Make view patterns right-associate
simonpj@microsoft.com**20100106160642
 Ignore-this: c91c4041cfb5da190fca17ef3c131584
 
 So that you can write
 
    f (v1 -> v2 -> pat)
] 
[Improve the handling of default methods
simonpj@microsoft.com**20100106160603
 Ignore-this: e7f7534579e2329616f6efe67777e91
 
 See the long Note [INLINE and default methods].  
 
 This patch changes a couple of data types, with a knock-on effect on
 the format of interface files.  A lot of files get touched, but is a
 relatively minor change.  The main tiresome bit is the extra plumbing
 to communicate default methods between the type checker and the
 desugarer.
] 
[Patch for shared libraries support on FreeBSD
Ian Lynagh <igloo@earth.li>**20100106185321
 From Maxime Henrion <mhenrion@gmail.com>
] 
[Following Simon M's "take newCAF() out from sm_mutex" patch
dias@cs.tufts.edu**20100105211543
 Ignore-this: 9a94ac919479160167724f717813532c
] 
[Very minor refactoring
simonpj@microsoft.com**20100105101833
 Ignore-this: f09724cc01e64968a35be6685eaa0ec2
] 
[Undo the fix for Trac #3772 and do it a new way
simonpj@microsoft.com**20100105101600
 Ignore-this: 4495159621267e7b95e2c2ea54cb11e3
 
 The main idea is that I'm now treating a single-method dictionary very
 much like a multi-method dictionary.  In particular, it respond to
 exprIsConApp_maybe, even though newtypes aren't *really* proper
 constructors.
 
 See long comments with Note [Single-method classes] for why
 this slight hack is justified.
] 
[Fix warnings
simonpj@microsoft.com**20100105100945
 Ignore-this: 23123788ec2b782c4491c0687bc51bf1
] 
[Improve error message (idea in Trac #3805)
simonpj@microsoft.com**20100105095532
 Ignore-this: 109f041bb2a3be3beafc536aa5b8d9f
 
 If we see
 
    foreign export ccall foo :: ...blah...
 
 we now use the "foreign" to suggest -XForeignFunctionInterface
] 
[Comments only
simonpj@microsoft.com**20100105095356
 Ignore-this: f61734a530c6c2cdd38643829a918f23
] 
[Continue refactoring the core-to-core pipeline
simonpj@microsoft.com**20091224154643
 Ignore-this: 23451f6ec98081c82197b20486d8e47d
 
 This patch mainly concerns the plumbing for running
 the passes and printing intermediate output
] 
[A bunch of stuff relating to substitutions on core
simonpj@microsoft.com**20091224153949
 Ignore-this: aff1cc9ef94a41b334a3493bfd894292
 
 * I was debugging so I added some call-site info
   (that touches a lot of code)
 
 * I used substExpr a bit less in Simplify, hoping to
   make the simplifier a little faster and cleaner
] 
[Refactor CoreArity a bit
simonpj@microsoft.com**20091224153448
 Ignore-this: 70acb5f535ffdc1a82bc18214bb3a6e8
 
 I was experimenting with making coercions opaque to
 arity.  I think this is ultimately the right thing to do
 but I've left the functionality unchanged for now.
] 
[Wibbles to inlining for small functions
simonpj@microsoft.com**20091222162731
 Ignore-this: a4de5d1dfb414cab4d16df59a2248701
 
 See Note [INLINE for small functions]
] 
[Print out a bit more info with the "arity decrease" waring
simonpj@microsoft.com**20091222162606
 Ignore-this: 26eb76dfafe51ff74d5f7799069b4ed0
] 
[Move isDictTy from TcType to Type
simonpj@microsoft.com**20091222162550
 Ignore-this: 85ed4466f1e3d296845f914be79c7a54
] 
[Allow instance heads to use infix syntax
simonpj@microsoft.com**20091222162325
 Ignore-this: 54da2aa4208ee6757a80fa916c4afd6c
 
   class C a b
   instance Int `C` Bool
 
 This was accidentally disallowed before.
] 
[Fix pretty-printer
simonpj@microsoft.com**20091222162130
 Ignore-this: 64957ca5ae58ddade799355dd14f30e1
] 
[Fix Trac #3792: check for qualified names in import items
simonpj@microsoft.com**20100104215950
 Ignore-this: 12ff8d232e1ecf02b56bb8c03265bc53
] 
[Fix bugs in STG Lint
simonpj@microsoft.com**20100104214659
 Ignore-this: c10cbfdbbb9ea44d408cd5d2237b46b1
 
 The Stg Lint failure reported in Trac #3789 were bogus.
 This patch fixes STG Lint, which must have been unused
 for ages.
] 
[Refactor PackageTarget back into StaticTarget
Ben.Lippmeier@anu.edu.au**20100104031506
 Ignore-this: 14de03e800ae6e16ac952656817dce1c
] 
[Follow PackageTarget changes in pprCEntity
Ben.Lippmeier@anu.edu.au**20100102235053
 Ignore-this: db33b178fa1488a6132d9074abb91a50
] 
[Assume CmmLabels have dynamic linkage on non-Windows
Ben.Lippmeier.anu.edu.au**20100102100334
 Ignore-this: ed53fac02ebdd83e0e1b80fd8c211f19
] 
[Follow PackageTarget change in byte code generator
Ben.Lippmeier@anu.edu.au**20100102093046
 Ignore-this: ca6311be11ad22bdecb567cec4f395d8
] 
[When compiling viac, don't need to emit prototypes for symbols in the RTS
Ben.Lippmeier@anu.edu.au**20100102092957
 Ignore-this: 666616c2094070705dfb8d982f8ddfd8
] 
[Follow ForeignLabel changes in PPC NCG
Ben.Lippmeier@anu.edu.au**20100102062315
 Ignore-this: fdc42b45d134c542c5df0a86c660fd0d
] 
[Tag ForeignCalls with the package they correspond to
Ben.Lippmeier@anu.edu.au**20100102053754] 
[Nicer panic message
Ben.Lippmeier@anu.edu.au**20091229103518] 
[Typo in comment
Ben.Lippmeier@anu.edu.au**20091229051858] 
[Windows DLLs: use DLL aware runSparks_closure instead of base_GHCziConc_runSparks_closure directly
Ben.Lippmeier@anu.edu.au**20091123051510] 
[locateOneObj: don't look for dynamic libs in static mode
Simon Marlow <marlowsd@gmail.com>**20100103223637
 Ignore-this: 47e5d5eb1b27073b9afa1d804c83c7cd
 also replace picIsOn with isDynamicGhcLib, as __PIC__ is not the
 correct test for whether the GHC library is dynamically linked.
] 
[Substantial improvements to coercion optimisation
simonpj@microsoft.com**20100104082155
 Ignore-this: 376f5cc54c399c4910c21ba2be353655
 
 The main purpose of this patch is to add a bunch of new rules
 to the coercion optimiser.  They are documented in the (revised)
 Appendix of the System FC paper.  
 
 Some code has moved about:
 
 - OptCoercion is now a separate module, mainly because it
   now uses tcMatchTy, which is defined in Unify, so OptCoercion
   must live higehr up in the hierarchy
 
 - Functions that manipulate Kinds has moved from 
   Type.lhs to Coercion.lhs.  Reason: the function typeKind
   now needs to call coercionKind.  And in any case, a Kind is
   a flavour of Type, so it builds on top of Type; indeed Coercions
   and Kinds are both flavours of Type.
 
   This change required fiddling with a number of imports, hence
   the one-line changes to otherwise-unrelated modules
 
 - The representation of CoTyCons in TyCon has changed.   Instead of
   an extensional representation (a kind checker) there is now an
   intensional representation (namely TyCon.CoTyConDesc).  This was
   needed for one of the new coercion optimisations.
] 
[Whitespace only
Ian Lynagh <igloo@earth.li>**20100102220556] 
[Use a shell script, rather than perl script, to make flags.xsl
Ian Lynagh <igloo@earth.li>**20091231155004] 
[Rolling back: Make FastString thread-safe.
Simon Marlow <marlowsd@gmail.com>**20091231164651
 Ignore-this: 8f21b256b0c86d167f8f6984d2b27a87
     
 This patch was the cause of the compile-time performance regression in
 #3796.  My guess is that it is due to the use of unsafePerformIO which
 traverses the stack up to the first update frame, and perhaps we have
 a deep stack when reading the dictionary from a .hi file.  In any
 case, since we're not relying on thread safety for FastStrings, I
 think the safest thing to do is back this out until we can investigate
 further.
] 
[take newCAF() out from sm_mutex; use the capability-local mut list instead
Simon Marlow <marlowsd@gmail.com>**20091231160223
 Ignore-this: 81a9a0a1e279dea805a4ffd9cf124c90
] 
[Use local mut lists in UPD_IND(), also clean up Updates.h
Simon Marlow <marlowsd@gmail.com>**20091231113435
 Ignore-this: a4659d4d24f8c6626fa8403314c6a2e4
] 
[use local mut lists rather than global mut lists in sequential GC
Simon Marlow <marlowsd@gmail.com>**20091231113118
 Ignore-this: 782239ddca2a0ec5c928c310b1fad4e9
] 
[Allow throwTo() to be called without a source thread
Simon Marlow <marlowsd@gmail.com>**20091218163200
 Ignore-this: cb7265bc6c1c75f0dd49501c1bb74f64
 Returns false if the exception could not be thrown becuase the tartget
 thread was running.  Not used yet, but might come in handy later.
] 
[If ACTIVITY_INACTIVE is set, wait for GC before resetting it
Simon Marlow <marlowsd@gmail.com>**20091213201246
 Ignore-this: a3cd1a3aacbd68789ccc191e3b8d7778
 I don't think this fixes any real bugs, but there's a small
 possibility that when the RTS is woken up for an idle-time GC, the IO
 manager thread might be pre-empted which would prevent the idle GC
 from happening; this change ensures that the idle GC happens anyway.
] 
[Fix rules/build-dependencies.mk on OS X
Ian Lynagh <igloo@earth.li>**20091230185239
 Also more comments on why we have the sed rules that we do.
] 
[Copying Simon M's fix for 650 to the new codegen
dias@cs.tufts.edu**20091222222017
 Ignore-this: 4bd46e6ef23debc39c7c10aea3dfdf5c
] 
[Better error checking and code cleanup
dias@cs.tufts.edu**20091222221946
 Ignore-this: 16e89f4115cb392ebbb0899c081157ed
] 
[Add comments to darcs-all
simonpj@microsoft.com**20091221160511
 Ignore-this: 5a369a030785aec6ef0169e36757bba4
 
 The comments explain how darcs-all decides what repo to use
] 
[Fix Trac #3772: dict funs for single-field classes
simonpj@microsoft.com**20091221160431
 Ignore-this: 808f1a0633c600689653ab4763dc8628
 
 This patch fixes a bug that meant that INLINE pragamas on
 a method of a single-field class didn't work properly.
 
 See Note [Single-method classes] in TcInstDcls, and Trac #3772
] 
[Comments only (about implementing SPECIALISE pragmas)
simonpj@microsoft.com**20091221155745
 Ignore-this: c8c98b061c162a4585ff1141b65ea91a
] 
[A bit of refactoring, plus a sanity check
simonpj@microsoft.com**20091221155632
 Ignore-this: ba3efed78ce0b752f26891179d6b3987
 
 Check that a bottoming rhs does indeed get exposed with bottoming strictness
 Almost all the changed lines reflect some refactoring of tidyTopIdInfo.
] 
[Fix Trac #3776
simonpj@microsoft.com**20091221155509
 Ignore-this: 69607bdc7208775a305a5f39a575f0e2
 
 An easy fix.  See Note [Usage for sub-bndrs] in RnEnv.
] 
[Move all the CoreToDo stuff into CoreMonad
simonpj@microsoft.com**20091218164521
 Ignore-this: 57b3f63c1faa82f7246ca46e4c9a4412
 
 This patch moves a lot of code around, but has zero functionality change.
 The idea is that the types
 
     CoreToDo
     SimplifierSwitch	
     SimplifierMode
     FloatOutSwitches
 
 and 
 
     the main core-to-core pipeline construction
 
 belong in simplCore/, and *not* in DynFlags.
] 
[Always expose the unfolding of something with an InlineRule
simonpj@microsoft.com**20091218164316
 Ignore-this: 4f952f423848b8840fab69d63ee81d8f
 
 Previously a bottoming function with a strictness wrapper 
 had a hidden inlining, and that was Very Bad, because in 
     f x = if ... then bot_fun x else x+1
 we really want to pass the *unboxed* x to bot_fun. This
 happens quite a bit in error handling code, eg for array
 indexing.
] 
[Comments only
simonpj@microsoft.com**20091218164119
 Ignore-this: b4731841b036e614385cadbdfeda70b0
] 
[Move loop-breaker info from original function to worker in work/wrap
simonpj@microsoft.com**20091218164107
 Ignore-this: cc5c062f02577834baa5031e25497c57
 
 When doing a w/w split, if the original function is a loop breaker
 then the worker (not the wrapper) becomes one instead.
 
 This isn't very important, because loop breaker information is
 recalculated afresh by the occurrence analyser, but it seems more
 kosher.  And Lint was bleating piteously about things with InlineRules
 that were loop breakers.
] 
[Make -ddump-inlinings and -ddump-rule-firings less noisy 
simonpj@microsoft.com**20091218163742
 Ignore-this: aea0634c569afd5486de9c6e7dad2ae2
 
 By default, these two now print *one line* per inlining or rule-firing.
 
 If you want the previous (voluminous) behaviour, use -dverbose-core2core.
] 
[Make warning printing a bit less noisy
simonpj@microsoft.com**20091218163549
 Ignore-this: 86bc5d020b077b6c9d666d3e4d93bd1e
 
 Use -dppr-debug to make it noisy again
] 
[Set fixity (left-assoc) for setIdOccInfo
simonpj@microsoft.com**20091218163513
 Ignore-this: 6de9c34824e7713d120c889fc019a72a
] 
[Comments only
simonpj@microsoft.com**20091218105434
 Ignore-this: 48a8ed9e9703b412a7dd3201f22cf92d
] 
[Add an extra heading in the output for count_lines
simonpj@microsoft.com**20091218105403
 Ignore-this: 9e4e91930aba49ad6a247aa1d38297cd
] 
[Fixes to account for the new layout of MUT_ARR_PTRS (see #650)
Simon Marlow <marlowsd@gmail.com>**20091221115249
 Ignore-this: ca4a58628707b362dccedb74e81ef052
] 
[Partial support for Haiku (#3727)
Simon Marlow <marlowsd@gmail.com>**20091221110250
 Ignore-this: 5d4a3104c1bd50b7eae64780cb73071d
] 
[Fix #3751, also fix some lexical error SrcLocs
Simon Marlow <marlowsd@gmail.com>**20091217132658
 Ignore-this: 63e11a7a64bb0c98e793e4cc883f051d
] 
[kill some old GRAN/PARALLEL_HASKELL code
Simon Marlow <marlowsd@gmail.com>**20091217103816
 Ignore-this: 9bcfe3e62c556074a6f9396385ba1cf4
] 
[improve panic messages for srcLocLine, srcLocCol
Simon Marlow <marlowsd@gmail.com>**20091217103801
 Ignore-this: f58623a39bcc65201f150ce9560739d1
] 
[Tweak the build-dependencies rule, and add comments for it
Ian Lynagh <igloo@earth.li>**20091219145808] 
[When removing $(TOP) with sed, do so case insensitively
Ian Lynagh <igloo@earth.li>**20091219135339
 This avoids problems on Windows, where drive letters may not be the
 case we expect.
] 
[Fix a braino in a comment
Ian Lynagh <igloo@earth.li>**20091218213541] 
[Avoid a failing shell command when cleaning
Ian Lynagh <igloo@earth.li>**20091218201146
 It wasn't fatal, but better to avoid it anyway
] 
[Fix another sed problem on Solaris
Ian Lynagh <igloo@earth.li>**20091217000421] 
[unused named variables
dias@cs.tufts.edu**20091218195430
 Ignore-this: c2d56a21a039bb73023c54883a8c1fa3
] 
[missed a case in a previous fix
dias@cs.tufts.edu**20091217210443
 Ignore-this: ff40b8516a3de3fc36a55534620e4f50
 
 Here's the obscure problem:
 -- However, we also want to allow an assignment to be generated
 -- in the case when the types are compatible, because this allows
 -- some slightly-dodgy but occasionally-useful casts to be used,
 -- such as in RtClosureInspect where we cast an HValue to a MutVar#
 -- so we can print out the contents of the MutVar#.  If we generate
 -- code that enters the HValue, then we'll get a runtime panic, because
 -- the HValue really is a MutVar#.  The types are compatible though,
 -- so we can just generate an assignment.
 
] 
[Fix #650: use a card table to mark dirty sections of mutable arrays
Simon Marlow <marlowsd@gmail.com>**20091217224228
 Ignore-this: 75c354682c9ad1b71b68b5bc4cedd6de
 The card table is an array of bytes, placed directly following the
 actual array data.  This means that array reading is unaffected, but
 array writing needs to read the array size from the header in order to
 find the card table.
 
 We use a bytemap rather than a bitmap, because updating the card table
 must be multi-thread safe.  Each byte refers to 128 entries of the
 array, but this is tunable by changing the constant
 MUT_ARR_PTRS_CARD_BITS in includes/Constants.h.
] 
[Fix build with Solaris sed
Ian Lynagh <igloo@earth.li>**20091216204354
 Rather than trying to handle tabs with sed portably, we just use tr to
 remove them before we start.
] 
[Build and install inplace the count_lines and compareSizes utils
Ian Lynagh <igloo@earth.li>**20091216165608] 
[Adjust Activations for specialise and work/wrap, and better simplify in InlineRules
simonpj@microsoft.com**20091216145205
 Ignore-this: 2606cf9b00f2172097332b8b25b0553c
 
 This patch does two main things:
 
 1. Adjusts the way we set the Activation for
 
    a) The wrappers generated by the strictness analyser
       See Note [Wrapper activation] in WorkWrap
 
    b) The RULEs generated by Specialise and SpecConstr
       See Note [Auto-specialisation and RULES] in Specialise
           Note [Transfer activation] in SpecConstr
 
 2. Refines how we set the phase when simplifying the right
    hand side of an InlineRule.  See
    Note [Simplifying inside InlineRules] in SimplUtils.
 
 Most of the extra lines are comments!  
 
 The merit of (2) is that a bit more stuff happens inside InlineRules,
 and that in turn allows better dead-code elimination.
] 
[Comments only
simonpj@microsoft.com**20091216144908
 Ignore-this: 3dae7793802ded696b01f891a77aaf8
] 
[fix up libm detection and use (#3724)
Simon Marlow <marlowsd@gmail.com>**20091216113652
 Ignore-this: 6bbdd7302b262ac3b8ddc5c852dc538
] 
[configure.ac: fix libm checks (Trac #3730)
Sergei Trofimovich <slyfox@inbox.ru>**20091204214012
 Ignore-this: f3372535a68f3833247f679b023745c8
 
 libbfd pulled libm as dependency and broke LIBM= detection.
 
 Patch moves libm in library tests as early as possible.
 Thanks to asuffield for suggesting such a simple fix.
 Thanks to Roie Kerstein and Renato Gallo for finding
 and tracking down the issue.
] 
[#include <sys/select.h> if we have it (#3760)
Simon Marlow <marlowsd@gmail.com>**20091216095501
 Ignore-this: 7c00991a67ae6715e16c6458bf0b78af
] 
[add a couple of assertions
Simon Marlow <marlowsd@gmail.com>**20091123101918
 Ignore-this: e631da990055fd28156a6c887e1468ca
] 
[Add comments
simonpj@microsoft.com**20091216090344
 Ignore-this: 6468afc939ab795d5a0eb9fd5dc08a48
] 
[Refactor to combine two eqExpr functions
simonpj@microsoft.com**20091216085033
 Ignore-this: 925dec0fc9af1e0a9359226359627ae7
 
 I'd forgotten that Rules.lhs already has an eqExpr function.  This
 patch combines Rules.eqExpr with the (recent) CoreUtils.eqExpr.
 
 I also did a little refactoring by defining CoreSyn.expandUnfolding_maybe
 (see Note [Expanding variables] in Rules.lhs), and using it in
      a) CoreUnfold.exprIsConApp_maybe
      b) Rule matching
] 
[Two improvements to optCoercion
simonpj@microsoft.com**20091216084706
 Ignore-this: 699d2deb1b1bf0c7bd7afb809bee26d2
 
 * Fix a bug that meant that 
      (right (inst (forall tv.co) ty)) 
   wasn't getting optimised.  This showed up in the
   compiled code for ByteCodeItbls
 
 * Add a substitution to optCoercion, so that it simultaneously
   substitutes and optimises.  Both call sites wanted this, and
   optCoercion itself can use it, so it seems a win all round.
] 
[Comments only
simonpj@microsoft.com**20091216084558
 Ignore-this: e5fc7949893dbbdc756d0616647a999b
] 
[Make setInlineActivation left-associative
simonpj@microsoft.com**20091216084536
 Ignore-this: 4d166f158c79c819ac73a0368e52473c
] 
[Fix a long-standing infelicity in the type pretty printer
simonpj@microsoft.com**20091216084513
 Ignore-this: 2d99f8733f6642671fcb88f2179e91e9
 
 We weren't parenthesising 
    List (C Int)
 correctly, when (C Int) is a PredTy
] 
[Deal with warnings in Coercion.lhs
simonpj@microsoft.com**20091216084053
 Ignore-this: 8f5a0537c76ed366003253e1f550d4f5
] 
[Fix a bug in the in-scope set that led to some lookupIdSubst errors
simonpj@microsoft.com**20091215160216
 Ignore-this: ed89f1bf6ece2c1e1cd135f11b130786
] 
[Fix Trac #3717: exprOkForSpeculation should look through case expressions
simonpj@microsoft.com**20091215160124
 Ignore-this: 1b848137f7fb81b2c1f72cc903f1c008
 
 See Note [exprOkForSpeculation: case expressions] in CoreUtils
] 
[Add a size-comparison util
Ian Lynagh <igloo@earth.li>**20091215202636] 
[Just make C dependencies once, rather than each way
Ian Lynagh <igloo@earth.li>**20091215135350
 This makes generating C dependencies for the RTS take 3 seconds, rather
 than 30.
] 
[Make addCFileDeps quieter
Ian Lynagh <igloo@earth.li>**20091215134033
 Move a comment out of the definition, so it doesn't get printed as
 a shell command every time we call the definition
] 
[Don't make C deps for compiler/parser/cutils.c in stage1
Ian Lynagh <igloo@earth.li>**20091215123757
 CPP finds the Rts.h, RtsFlags.h etc from the tree, rather than the
 bootstrapping compiler, and then fails because it doesn't think
 RtsFlags.h should be used any more.
] 
[Tidy up computation of result discounts in CoreUnfold
simonpj@microsoft.com**20091214134647
 Ignore-this: 351076027f8e9cb8aa44db6d60798c47
 
 Mostly this patch is a tidy-up, but it did reveal one inconsistency
 that I fixed.  When computing result discounts for case expressions,
 we were *adding* result-discounts for cases on non-arguments, but
 *picking the one for the max-size branch* for arguments. I think you
 could argue the toss, but it seems neater (and the code is nicer)
 to be consistent (ie always add).  See Note [addAltSize result discounts].
 
 The nofib results seem fine
 
         Program           Size    Allocs   Runtime   Elapsed
 --------------------------------------------------------------------------------
           boyer          -0.8%     -4.8%      0.06      0.07
          sphere          -0.7%     -2.5%      0.15      0.16
 --------------------------------------------------------------------------------
             Min          -0.8%     -4.8%    -19.1%    -24.8%
             Max          -0.5%     +0.0%     +3.4%   +127.1%
  Geometric Mean          -0.7%     -0.1%     -4.3%     -1.3%
 
 The +127% elapsed is a timing error; I re-ran the same binary and it's
 unchanged from the baseline.
] 
[Use full equality for CSE
simonpj@microsoft.com**20091211173920
 Ignore-this: c6d73febf652aa34dc1197a49e599ee
 
 In CSE we were getting lots of apprarently-unequal expressions with
 the same hash code.  In fact they were perfectly equal -- but we were
 using a cheap-and-cheerful equality tests for CoreExpr that said False
 for any lambda expression!
 
 This patch adds a proper equality test for Core, with alpha-renaming.
 It's easy to do, and will avoid silly cases of CSE failing to fire.
 
 We should get less of this:
   WARNING: file compiler/simplCore/CSE.lhs line 326
   extendCSEnv: long list, length 18
 from a compiler built with -DDEBUG
] 
[Improve strictness analysis for bottoming functions
simonpj@microsoft.com**20091211162324
 Ignore-this: dd5ef03a1b4728c25a2333f59024dc9c
 
 I found the following results from strictness analyis:
   f x = error (fst x)      -- Strictness U(SA)b
   g x = error ('y':fst x)  -- Strictness Tb
 
 Surely 'g' is no less strict on 'x' than 'f' is!  The fix turned out
 be to very nice and simple.  See Note [Bottom demands] in DmdAnal.
] 
[Bottom extraction: float out bottoming expressions to top level
simonpj@microsoft.com**20091211161928
 Ignore-this: a1a96b36dc982d83f5c01a4259518b
   
 The idea is to float out bottoming expressions to top level,
 abstracting them over any variables they mention, if necessary.  This
 is good because it makes functions smaller (and more likely to
 inline), by keeping error code out of line. 
 
 See Note [Bottoming floats] in SetLevels.
 
 On the way, this fixes the HPC failures for cg059 and friends.
 
 I've been meaning to do this for some time.  See Maessen's paper 1999
 "Bottom extraction: factoring error handling out of functional
 programs" (unpublished I think).
 
 Here are the nofib results:
 
 
         Program           Size    Allocs   Runtime   Elapsed
 --------------------------------------------------------------------------------
             Min          +0.1%     -7.8%    -14.4%    -32.5%
             Max          +0.5%     +0.2%     +1.6%    +13.8%
  Geometric Mean          +0.4%     -0.2%     -4.9%     -6.7%
 
 Module sizes
         -1 s.d.                -----           -2.6%
         +1 s.d.                -----           +2.3%
         Average                -----           -0.2%
 
 Compile times:
         -1 s.d.                -----          -11.4%
         +1 s.d.                -----           +4.3%
         Average                -----           -3.8%
 
 I'm think program sizes have crept up because the base library
 is bigger -- module sizes in nofib decrease very slightly.  In turn
 I think that may be because the floating generates a call where
 there was no call before.  Anyway I think it's acceptable.
 
 
 The main changes are:
 
 * SetLevels floats out things that exprBotStrictness_maybe 
   identifies as bottom.  Make sure to pin on the right 
   strictness info to the newly created Ids, so that the
   info ends up in interface files.
 
   Since FloatOut is run twice, we have to be careful that we
   don't treat the function created by the first float-out as
   a candidate for the second; this is what worthFloating does.
 
   See SetLevels Note [Bottoming floats]
                 Note [Bottoming floats: eta expansion]
 
 * Be careful not to inline top-level bottoming functions; this 
   would just undo what the floating transformation achieves.
   See CoreUnfold Note [Do not inline top-level bottoming functions
  
   Ensuring this requires a bit of extra plumbing, but nothing drastic..
 
 * Similarly pre/postInlineUnconditionally should be 
   careful not to re-inline top-level bottoming things!
   See SimplUtils Note [Top-level botomming Ids]
                  Note [Top level and postInlineUnconditionally]
] 
[Expose all EventLog events as DTrace probes
Manuel M T Chakravarty <chak@cse.unsw.edu.au>**20091212100809
 Ignore-this: 2c5ef30b1ff7fb2ea5fba8cf0a187d45
 - Defines a DTrace provider, called 'HaskellEvent', that provides a probe
   for every event of the eventlog framework.
 - In contrast to the original eventlog, the DTrace probes are available in
   all flavours of the runtime system (DTrace probes have virtually no
   overhead if not enabled); when -DTRACING is defined both the regular
   event log as well as DTrace probes can be used.
 - Currently, Mac OS X only.  User-space DTrace probes are implemented
   differently on Mac OS X than in the original DTrace implementation.
   Nevertheless, it shouldn't be too hard to enable these probes on other
   platforms, too.
 - Documentation is at http://hackage.haskell.org/trac/ghc/wiki/DTrace
] 
[Fix two related bugs in u_tys
simonpj@microsoft.com**20091211120122
 Ignore-this: 25e826e0915c6f6267cadff96f1d7ca6
 
 When we normalise a type family application we must recursively call
 uTys, *not* 'go', because the latter loop is only there to look
 through type synonyms.  This bug made the type checker generate
 ill-typed coercions, which were rejected by Core Lint.
 
 A related bug only affects the size of coercions.  If faced with
   (m a) ~ (F b c)
 where F has arity 1, we want to decompose to 
    m ~ F Int,  a ~ c
 rather than deferring.  The application decomposition was being
 tried last, so we were missing this opportunity.
 
 Thanks to Roman for an example that showed all this up.
] 
[Fix spelling in comment
simonpj@microsoft.com**20091211115744
 Ignore-this: bd02fc0eb67efc7404536f1ee96d4d1f
] 
[Make -ddump-simpl-stats a bit more informative by default
simonpj@microsoft.com**20091208175445
 Ignore-this: 1bbe3f4c4b727a3b1580236c1f9c2583
 
 This mades -ddump-simpl-stats print out per-rule and per-id
 information by default, rather than requiring -dppr-debug.
 On the whole that is what you want.  The -dppr-debug flag
 now just controls printing of the log.
] 
[Improve dumping for rules, and documentation of same
simonpj@microsoft.com**20091208105556
 Ignore-this: 4b09e56f953d130d5cb2807cf9da7303
 
 Inspired by Trac #3703
] 
[Fix #3741, simplifying things in the process
Simon Marlow <marlowsd@gmail.com>**20091210160909
 Ignore-this: 8a668af4eb9e1aa71b4764b84f148dac
 The problem in #3741 was that we had confused column numbers with byte
 offsets, which fails in the case of UTF-8 (amongst other things).
 Fortunately we're tracking correct column offsets now, so we didn't
 have to make a calculation based on a byte offset.  I got rid of two
 fields from the PState (last_line_len and last_offs).and one field
 from the AI (alex input) constructor.
] 
[Allow spaces at either end of the C import spec (#3742)
Simon Marlow <marlowsd@gmail.com>**20091210124537
 Ignore-this: 840424ea49d5e81ab8f8ce3209d5eedf
] 
[Put README and INSTALL into bindists
Ian Lynagh <igloo@earth.li>**20091209174305
 Also tidied up the way configure.ac gets into bindists
] 
[Fix typo
Ian Lynagh <igloo@earth.li>**20091209152223] 
[Fix the stage1 version number munging
Ian Lynagh <igloo@earth.li>**20091209151715
 It was munging 6.12.1 into 62
] 
[Add a comment about why $(CPP) is defined the way it is in config.mk.in
Ian Lynagh <igloo@earth.li>**20091209131917] 
[add a missing unlockTSO()
Simon Marlow <marlowsd@gmail.com>**20091209124113
 Ignore-this: 9ff0aedcb6d62e5b4bd2fab30bfce105
] 
[Eliminate mkdependC
Ian Lynagh <igloo@earth.li>**20091209123929
 We now just call gcc to get the dependencies directly
] 
[Change some HC_OPTS to CC_OPTS, so they are used when making dependencies
Ian Lynagh <igloo@earth.li>**20091208200315] 
[Add -Iincludes to hp2ps's CC_OPTS
Ian Lynagh <igloo@earth.li>**20091208175718
 Making C deps for hp2ps always failed, but we used to carry on regardless
] 
[add locking in mkWeakForeignEnv#
Simon Marlow <marlowsd@gmail.com>**20091208101229
 Ignore-this: 3902631687fc252c0e6794d58641371b
] 
[declare g0 (fixes compilation failure with -fvia-C)
Simon Marlow <marlowsd@gmail.com>**20091208100925] 
[simplify weak pointer processing
Simon Marlow <marlowsd@gmail.com>**20091208094822
 Ignore-this: d88091b23860eeba6cd971282b05c2e6
] 
[simplification/optimisation: update tso->bound->tso when scavenging the TSO
Simon Marlow <marlowsd@gmail.com>**20091208085739
 Ignore-this: 401e2c67e42de9671191ba9d18c3fcf7
] 
[threadStackUnderflow: fix recently introduced bug (conc068(threaded1) failure)
Simon Marlow <marlowsd@gmail.com>**20091207170127
 Ignore-this: cab7b66b3b1478d44ad5272eeec84004
 
 bug introduced by "threadStackUnderflow: put the new TSO on the mut
 list if necessary"
] 
[need locking around use of weak_ptr_list in mkWeak#
Simon Marlow <marlowsd@gmail.com>**20091207145213
 Ignore-this: 9c7d506c30652de4dd5c47d1989022c1
] 
[remove global 'total_allocated', seems to be the same as 'GC_tot_alloc'
Simon Marlow <marlowsd@gmail.com>**20091207115359
 Ignore-this: d174f167a2be6864bbab672f3d5b7c5
] 
[Add some explanation about overlapping instances
simonpj@microsoft.com**20091207153915
 Ignore-this: 627db39187f0ed8a10fe46e667a849a
 
 Trac #3734 suggested addding some extra guidance about 
 incoherence and overlap; now done
] 
[Tidy up deriving error messages
simonpj@microsoft.com**20091207130850
 Ignore-this: 4e134f6b62814ea6f361df7525c25a2d
 
 I did this in response to a suggestion in Trac #3702
] 
[Fix profiling build
Simon Marlow <marlowsd@gmail.com>**20091207092314
 Ignore-this: eb397ec713cb7a8f6e56f409e0663ffe
] 
[Minor refactoring to remove redundant code
simonpj@microsoft.com**20091207083312
 Ignore-this: 3203447fa823823ae27565f53d39bd10
] 
[Fix a nasty (and long-standing) FloatOut performance bug
simonpj@microsoft.com**20091207083246
 Ignore-this: a64b98992fa4ced434d1edf0b89842ec
 
 The effect was that, in deeply-nested applications, FloatOut would
 take quadratic time.  A good example was compiling 
     programs/barton-mangler-bug/Expected.hs
 in which FloatOut had a visible pause of a couple of seconds!
 Profiling showed that 40% of the entire compile time was being
 consumbed by the single function partitionByMajorLevel.
 
 The bug was that the floating bindings (type FloatBinds) was kept
 as a list, which was partitioned at each binding site.  In programs
 with deeply nested lists, such as
        e1 : e2 : e3 : .... : e5000 : []
 this led to quadratic behaviour.
 
 The solution is to use a proper finite-map representation;
 see the new definition of FloatBinds near the bottom of FloatOut.
] 
[Add a new to-do to cmm-notes
simonpj@microsoft.com**20091207081130
 Ignore-this: fc835da15dd8a206c2c1bdc6c7053c5b
] 
[Comments only, principally about IfaceDeclExtras
simonpj@microsoft.com**20091207081108
 Ignore-this: 1004303ab0df7802295d67c613c4ab24
] 
[Comments only, about RULE plumbing
simonpj@microsoft.com**20091207080442
 Ignore-this: 1a559744f6ad75e151afbfb2281bceb4
] 
[Add splitUFM to UniqFM (used in a forthcoming patch)
simonpj@microsoft.com**20091204160820
 Ignore-this: 332aa029f25ec3f22e4f195ecd44b40b
 
 splitUFM :: Uniquable key => UniqFM elt -> key -> (UniqFM elt, Maybe elt, UniqFM elt)
    -- Splits a UFM into things less than, equal to, and greater than the key
] 
[Add lengthBag to Bag (using in forthcoming patch)
simonpj@microsoft.com**20091204155055
 Ignore-this: 5af0f45d6b51bc77e54c5cb0e2b1e607
] 
[Use addToUFM_Acc where appropriate
simonpj@microsoft.com**20091204155036
 Ignore-this: 38e768c4a9f00d7870a631a9472e6edc
 
 This way of extending a UniqFM has existed for some time, but
 we weren't really using it.
 
 addToUFM_Acc	:: Uniquable key =>
 			      (elt -> elts -> elts)	-- Add to existing
 			   -> (elt -> elts)		-- New element
 			   -> UniqFM elts 		-- old
 			   -> key -> elt 		-- new
 			   -> UniqFM elts		-- result
] 
[Add comments to "OPTIONS_GHC -fno-warn-orphans" pragmas
Ian Lynagh <igloo@earth.li>**20091205165721] 
[Add some missing exports back for GHC package users; fixes trac #3715
Ian Lynagh <igloo@earth.li>**20091205153532] 
[Add some comments on the alternative layout rule state
Ian Lynagh <igloo@earth.li>**20091205152039] 
[Tweak layout for alternative layout rule
Ian Lynagh <igloo@earth.li>**20091203164424] 
[Link all dynamic libraries with the correct install_name on Mac OS/X.
Ian Lynagh <igloo@earth.li>**20091204143614
 This is a rerecord of
     Stephen Blackheath <oversensitive.pastors.stephen@blacksapphire.com>**20090930222855
 to avoid conflicts.
] 
[Document the new -dylib-install-name option in the user's guide.
Stephen Blackheath <oversensitive.pastors.stephen@blacksapphire.com>**20091001051637
 Ignore-this: 568f6ad423f737ccda3a79f2d8efdb97
] 
[Add -dylib-install-name option to GHC so the install name can be set for dynamic libs on Mac OS/X.
Stephen Blackheath <oversensitive.pastors.stephen@blacksapphire.com>**20090930223708
 Ignore-this: 2323929595c0dc03a2e2ea802477a930
] 
[Force -fPIC when linking against dynamic libraries on Mac OS/X.
Stephen Blackheath <oversensitive.pastors.stephen@blacksapphire.com>**20090928203800
 Ignore-this: 465433af2349779b510f500dc79768f3
 Otherwise you get
 /tmp/ghc7602_0/ghc7602_0.s:207:0:
    non-relocatable subtraction expression, "___stginit_Lib_dyn" minus "L1x2;4"
 /tmp/ghc7602_0/ghc7602_0.s:207:0:
    symbol: "___stginit_Lib_dyn" can't be undefined in a subtraction expression
] 
[evaluate_large: evaluate large objects to bd->dest rather than gen->to
Simon Marlow <marlowsd@gmail.com>**20091204111037
 Ignore-this: 6c77407750d4a6178851aeb79ded20d1
 This fixes aging of large objects in the new scheme.  Bug found by
 perf/space_leaks/space_leak_001.  Yay perf regressions tests.
] 
[Correction to the allocation stats following earlier refactoring
Simon Marlow <marlowsd@gmail.com>**20091204110839
 Ignore-this: 7ac497c67706bedd29c79091c100d22f
] 
[export g0
Simon Marlow <marlowsd@gmail.com>**20091203165209
 Ignore-this: 69b5445beb91ac99bb018b9806de90a
] 
[GC refactoring, remove "steps"
Simon Marlow <marlowsd@gmail.com>**20091203150728
 Ignore-this: 5360b8bf30c6847ccb7ffa8c431e81ff
 
 The GC had a two-level structure, G generations each of T steps.
 Steps are for aging within a generation, mostly to avoid premature
 promotion.  
 
 Measurements show that more than 2 steps is almost never worthwhile,
 and 1 step is usually worse than 2.  In theory fractional steps are
 possible, so the ideal number of steps is somewhere between 1 and 3.
 GHC's default has always been 2.
 
 We can implement 2 steps quite straightforwardly by having each block
 point to the generation to which objects in that block should be
 promoted, so blocks in the nursery point to generation 0, and blocks
 in gen 0 point to gen 1, and so on.
 
 This commit removes the explicit step structures, merging generations
 with steps, thus simplifying a lot of code.  Performance is
 unaffected.  The tunable number of steps is now gone, although it may
 be replaced in the future by a way to tune the aging in generation 0.
] 
[fix error message on Windows (fixes rtsflags001)
Simon Marlow <marlowsd@gmail.com>**20091202141135
 Ignore-this: 239fed52f7f5358b034acd6512d26ef4
] 
[Fix loading of annotations
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091204024259
 Ignore-this: 5750856feecbf9c6aeebfec012b1a1fd
 
 The problem was that we collected all annotations we knew about once when the
 simplifier started and threaded them through the CoreM monad. If new interface
 files were loaded during simplification, their annotations would not be
 visible to the simplifier.
 
 Now, we rebuild the annotation list at the start of every simplifier pass that
 needs it (which is only SpecConstr at the moment). This ensures that we see
 all annotations that have been loaded so far. This is somewhat similar to how
 RULES are handled.
] 
[Add new ForceSpecConstr annotation
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091203065455
 Ignore-this: ca5327f85d9d40c78d95e8bfe3e7fab1
 
 Annotating a type with {-# ANN type T ForceSpecConstr #-} makes SpecConstr
 ignore -fspec-constr-threshold and -fspec-constr-count for recursive functions
 that have arguments of type T. Such functions will be specialised regardless
 of their size and there is no upper bound on the number of specialisations
 that can be generated. This also works if T is embedded in other types such as
 Maybe T (but not T -> T).
 
 T should not be a product type because it could be eliminated by the
 worker/wrapper transformation. For instance, in
 
 data T = T Int Int
 
 foo :: T -> Int
 foo (T m n) = ... foo (T m' n') ...
 
 SpecConstr will never see the T because w/w will get rid of it. I'm still
 thinking about whether fixing this is worthwhile.
] 
[Generate INLINE pragmas for PA methods
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091203031452
 Ignore-this: 3435044aec2737ba58d269aeff915fbd
] 
[Add a GHC layout extension to the alternative layout rule
Ian Lynagh <igloo@earth.li>**20091203155708] 
[Fix HPC column numbers, following the column number changes in GHC
Ian Lynagh <igloo@earth.li>**20091203135520] 
[Whitespace only
Ian Lynagh <igloo@earth.li>**20091203132259] 
[Fix column numbers used when highlighting :list output
Ian Lynagh <igloo@earth.li>**20091203130328] 
[add a missing lock around allocGroup()
Simon Marlow <marlowsd@gmail.com>**20091203110209
 Ignore-this: 5898b3de4010e16789b628b004aa77db
] 
[remove unused cap->in_gc flag
Simon Marlow <marlowsd@gmail.com>**20091202154240
 Ignore-this: db2ef6c957c8d32233bbcc344e3c06b6
] 
[Refactoring only
Simon Marlow <marlowsd@gmail.com>**20091202123806
 Ignore-this: 95a93f6e330f2c609c197194412cac75
] 
[move sanity checking code from Storage.c to Sanity.c
Simon Marlow <marlowsd@gmail.com>**20091202121141
 Ignore-this: 216d434c3c3d2250effac22b37bc2b4d
] 
[stg_ap_0_fast: sanity-check only the topmost frame, not the whole stack
Simon Marlow <marlowsd@gmail.com>**20091202115109
 Ignore-this: ad45e07c26aa961913d367d7c53efb75
 Sanity checking was getting too slow in some cases, this returns it to
 a constant-factor overhead.
] 
[Fix profiling build
Simon Marlow <marlowsd@gmail.com>**20091203085930
 Ignore-this: ff3de527cbf7703e8bac4a48933cd8ba
] 
[More work on the simplifier's inlining strategies
simonpj@microsoft.com**20091202174256
 Ignore-this: 5840392a95d9a47f37c3074f7394f2c2
 
 This patch collects a small raft of related changes
 
 * Arrange that during 
      (a) rule matching and 
      (b) uses of exprIsConApp_maybe
   we "look through" unfoldings only if they are active
   in the phase. Doing this for (a) required a bit of 
   extra plumbing in the rule matching code, but I think
   it's worth it.
 
   One wrinkle is that even if inlining is off (in the 'gentle'
   phase of simplification) during rule matching we want to
   "look through" things with inlinings.  
    See SimplUtils.activeUnfInRule.
 
   This fixes a long-standing bug, where things that were
   supposed to be (say) NOINLINE, could still be poked into
   via exprIsConApp_maybe. 
 
 * In the above cases, also check for (non-rule) loop breakers; 
   we never look through these.  This fixes a bug that could make
   the simplifier diverge (and did for Roman).  
   Test = simplCore/should_compile/dfun-loop
 
 * Try harder not to choose a DFun as a loop breaker. This is 
   just a small adjustment in the OccurAnal scoring function
 
 * In the scoring function in OccurAnal, look at the InlineRule
   unfolding (if there is one) not the actual RHS, beause the
   former is what'll be inlined.  
 
 * Make the application of any function to dictionary arguments
   CONLIKE.  Thus (f d1 d2) is CONLIKE.  
   Encapsulated in CoreUtils.isExpandableApp
   Reason: see Note [Expandable overloadings] in CoreUtils
 
 * Make case expressions seem slightly smaller in CoreUnfold.
   This reverses an unexpected consequences of charging for
   alternatives.
 
 Refactorings
 ~~~~~~~~~~~~
 * Signficantly refactor the data type for Unfolding (again). 
   The result is much nicer.  
 
 * Add type synonym BasicTypes.CompilerPhase = Int
   and use it
 
 Many of the files touched by this patch are simply knock-on
 consequences of these two refactorings.
] 
[Fix Trac #3100: reifyType
simonpj@microsoft.com**20091130175204
 Ignore-this: ad1578c3d2e3da6128cd5052c8b64dc
 
 A type without any leading foralls may still have constraints
    eg:  ?x::Int => Int -> Int
 
 But reifyType was failing in this case.
 
 Merge to 6.12.
] 
[Fix Trac #3102: pre-matching polytypes
simonpj@microsoft.com**20091130174441
 Ignore-this: 3e3fa97e0de28b005a1aabe9e5542b32
 
 When *pre-matching* two types
      forall a. C1 => t1  ~  forall a. C2 => t2
 we were matching t1~t2, but totally ignoring C1,C2
 That's utterly wrong when pre-matching
        (?p::Int) => String  ~  a
 because we emerge with a:=String!
 
 All this is part of the impredicative story, which is about
 to go away, but still.
 
 Worth merging this to 6.12
] 
[threadStackUnderflow: put the new TSO on the mut list if necessary
Simon Marlow <marlowsd@gmail.com>**20091202144549
 Ignore-this: 839e7ad7893b3d7ea6481030ce7c6fe6
] 
[don't sanity check the whole stack when switching interp<->compiled
Simon Marlow <marlowsd@gmail.com>**20091202134121
 Ignore-this: 999b44d4dd096eceda81dda65f65a2df
] 
[fix to sanity checking for ThreadRelocated TSOs
Simon Marlow <marlowsd@gmail.com>**20091202134041
 Ignore-this: 52364f29041e6909b550956087649220
] 
[sanity check the top stack frame, not the whole stack
Simon Marlow <marlowsd@gmail.com>**20091202134020
 Ignore-this: c4c9b58c13299eecf7ec8cb79e34dc1f
] 
[Make allocatePinned use local storage, and other refactorings
Simon Marlow <marlowsd@gmail.com>**20091201160321
 Ignore-this: ec1334a9a5ec0de2567aa81d74b715ba
 
 This is a batch of refactoring to remove some of the GC's global
 state, as we move towards CPU-local GC.  
 
   - allocateLocal() now allocates large objects into the local
     nursery, rather than taking a global lock and allocating
     then in gen 0 step 0.
 
   - allocatePinned() was still allocating from global storage and
     taking a lock each time, now it uses local storage. 
     (mallocForeignPtrBytes should be faster with -threaded).
     
   - We had a gen 0 step 0, distinct from the nurseries, which are
     stored in a separate nurseries[] array.  This is slightly strange.
     I removed the g0s0 global that pointed to gen 0 step 0, and
     removed all uses of it.  I think now we don't use gen 0 step 0 at
     all, except possibly when there is only one generation.  Possibly
     more tidying up is needed here.
 
   - I removed the global allocate() function, and renamed
     allocateLocal() to allocate().
 
   - the alloc_blocks global is gone.  MAYBE_GC() and
     doYouWantToGC() now check the local nursery only.
] 
[Free full_prog_argv at exit, closing a memory leak
Simon Marlow <marlowsd@gmail.com>**20091201122801
 Ignore-this: 8fdb41e09bfc318821c427d2f22af737
] 
[free cap->saved_mut_lists too
Simon Marlow <marlowsd@gmail.com>**20091201113448
 Ignore-this: 973e1de140e104c126fe4a213791ba86
 fixes some memory leakage at shutdown
] 
[exitScheduler: move boundTaskExiting call outside #ifdef THREADED_RTS
Simon Marlow <marlowsd@gmail.com>**20091201113352
 Ignore-this: d913df43b14054f73c0fa06d0205952c
 Fixes a little leaked memory at shutdown in non-threaded RTS
] 
[Use dlltool from the in-tree mingw installation
Ian Lynagh <igloo@earth.li>**20091201190544
 We only use dlltool on Windows, and this way we don't require that
 the user has it installed.
] 
[Fix Commentary link in the HACKING file; trac #3706
Ian Lynagh <igloo@earth.li>**20091201150149] 
[Add an entry fo the ghci command :run to the user guide
Ian Lynagh <igloo@earth.li>**20091201173339] 
[Fix typo in docs
Ian Lynagh <igloo@earth.li>**20091201170550] 
[Delay expansion of some makefile variables until they are available
Ian Lynagh <igloo@earth.li>**20091201133609] 
[Call $(SED) rather than sed
Ian Lynagh <igloo@earth.li>**20091201131123] 
[Look for sed as gsed first
Ian Lynagh <igloo@earth.li>**20091201130741
 Solaris's sed apparently doesn't understand [:space:]
] 
[Avoid running empty for loops; fixes trac #3683
Ian Lynagh <igloo@earth.li>**20091201125927
 Solaris's sh gives
     /bin/sh: syntax error at line 1: `;' unexpected
 when faced with something like
     for x in ; do ...; done
 Patch from Christian Maeder.
] 
[Fix PS file generation
Simon Marlow <marlowsd@gmail.com>**20091201154254
 Ignore-this: 7b7122208e845b029a8b7215149fd203
 (the image doesn't work, but at least db2latex doesn't fall over)
] 
[Implement a new heap-tuning option: -H
Simon Marlow <marlowsd@gmail.com>**20091130151836
 Ignore-this: 2089b9dfaf6c095dc0460cef39e9d586
 
 -H alone causes the RTS to use a larger nursery, but without exceeding
 the amount of memory that the application is already using.  It trades
 off GC time against locality: the default setting is to use a
 fixed-size 512k nursery, but this is sometimes worse than using a very
 large nursery despite the worse locality.
 
 Not all programs get faster, but some programs that use large heaps do
 much better with -H.  e.g. this helps a lot with #3061 (binary-trees),
 though not as much as specifying -H<large>.  Typically using -H<large>
 is better than plain -H, because the runtime doesn't know ahead of
 time how much memory you want to use.
 
 Should -H be on by default?  I'm not sure, it makes some programs go
 slower, but others go faster.
] 
[Store a destination step in the block descriptor
Simon Marlow <marlowsd@gmail.com>**20091129164251
 Ignore-this: c406550acfe10141fcc38d3949d67490
 At the moment, this just saves a memory reference in the GC inner loop
 (worth a percent or two of GC time).  Later, it will hopefully let me
 experiment with partial steps, and simplifying the generation/step
 infrastructure.
] 
[Fix the prof_scc.png image in the profiling section (#3694)
Simon Marlow <marlowsd@gmail.com>**20091130132703
 Ignore-this: 9774bad70187274e3dd283d66703004
] 
[document 'recache' command in the help output (#3684)
Simon Marlow <marlowsd@gmail.com>**20091130122040
 Ignore-this: 95a51f76e66055af27cdfc7b5ad7deb3
] 
[Check whether the main function is actually exported (#414)
Simon Marlow <marlowsd@gmail.com>**20091130112327
 Ignore-this: 1afaa18d8c0c9e1d029531ac9d4865bb
] 
[Avoid using non-standard GNU tar option --force-local
Simon Marlow <marlowsd@gmail.com>**20091130112605
 Ignore-this: ac066722b15eb93e752d4f63391c9e3c
] 
[Reorder ALL_RTS_LIBS
Matthias Kilian <kili@outback.escape.de>**20091115175405
 Ignore-this: 795cfd5215ec73eea729aa2b3097817e
 
 ALL_RTS_LIBS is (ab)used for linking ghc when BootingFromHc=Yes,
 which needs libHSrtsmain.a before libHSrts.a.
 
] 
[Update dependencies
Ian Lynagh <igloo@earth.li>**20091129165534] 
[Follow Cabal changes
Ian Lynagh <igloo@earth.li>**20091129165141] 
[Tweak layout to work with alternative layout rule
Ian Lynagh <igloo@earth.li>**20091129163044] 
[Tweak the alternative layout rule: {} contains commas
Ian Lynagh <igloo@earth.li>**20091129155454] 
[Correct the advanceSrcLoc calculation for tabs
Ian Lynagh <igloo@earth.li>**20091129153933
 It was off-by-one
] 
[Tweak alternative layout rule
Ian Lynagh <igloo@earth.li>**20091129152323] 
[Make the alternative layout rule cope with file pragmas
Ian Lynagh <igloo@earth.li>**20091129145840] 
[Give more informative error messages
Ian Lynagh <igloo@earth.li>**20091129031029
 We used to just get
     ghc: panic! (the 'impossible' happened)
       (GHC version 6.13.20091128 for x86_64-unknown-linux):
         too few bytes. Failed reading at byte position 32753
 with no indication of what was being parsed.
] 
[Teach advanceSrcLoc about tab characters
Ian Lynagh <igloo@earth.li>**20091128151204] 
[Whitespace only
Ian Lynagh <igloo@earth.li>**20091128150731] 
[Columns now start at 1, as lines already did
Ian Lynagh <igloo@earth.li>**20091127224050
 Also corrected a couple of line 0's to line 1
] 
[Remove configure tests on tarballs that no longer exist
Ian Lynagh <igloo@earth.li>**20091127150101] 
[Implement non-decreasing do indentation in the alternative layout rule
Ian Lynagh <igloo@earth.li>**20091127011932] 
[add docs for Unicode entities in #2978
Simon Marlow <marlowsd@gmail.com>**20091125153649
 Ignore-this: f3d1561ef8f55606d9022ab7243e3800
] 
[Apply patch from #2978: add more Unicode syntax
Simon Marlow <marlowsd@gmail.com>**20090918130333
 Ignore-this: 1393009fdf2383ca43046ba0767a51e0
] 
[Use UTF-8 explicitly for InstalledPackageInfo
Simon Marlow <marlowsd@gmail.com>**20091125141730
 Ignore-this: 45be1506dd5c3339fb229a44aa958235
 So ghc-pkg register/update takes input in UTF-8, and ghc-pkg dump
 outputs in UTF-8.  Textual package config files in the package DB are
 assumed to be in UTF-8.
] 
[Comments only, esp about RecStmts
simonpj@microsoft.com**20091126163241
 Ignore-this: 6fb05bd70b1d0cbb55fb01cf1f17ea77
] 
[Fix a bug in alternative layout rule
Ian Lynagh <igloo@earth.li>**20091125231901] 
[Fix a bug in alternative layout
Ian Lynagh <igloo@earth.li>**20091125230616
 And make the code simpler in the process!
] 
[Bug fix for alternative layout rule
Ian Lynagh <igloo@earth.li>**20091125205809] 
[Tweak alternative layout rule
Ian Lynagh <igloo@earth.li>**20091125193854] 
[Add unboxed parentheses to the alternative layout rule
Ian Lynagh <igloo@earth.li>**20091125182421] 
[Tweak the warning suppression flags used in Lexer
Ian Lynagh <igloo@earth.li>**20091125171815] 
[Implement the alternative layout rule
Ian Lynagh <igloo@earth.li>**20091125171656
 Caution: Largely untested
] 
[Fix some warning in Lexer
Ian Lynagh <igloo@earth.li>**20091124233726] 
[threadStackOverflow: check whether stack squeezing released some stack (#3677)
Simon Marlow <marlowsd@gmail.com>**20091125125917
 Ignore-this: d35089eb93f5b367b7d1c445bda79232
 
 In a stack overflow situation, stack squeezing may reduce the stack
 size, but we don't know whether it has been reduced enough for the
 stack check to succeed if we try again.  Fortunately stack squeezing
 is idempotent, so all we need to do is record whether *any* squeezing
 happened.  If we are at the stack's absolute -K limit, and stack
 squeezing happened, then we try running the thread again.
 
 We also want to avoid enlarging the stack if squeezing has already
 released some of it.  However, we don't want to get into a
 pathalogical situation where a thread has a nearly full stack (near
 its current limit, but not near the absolute -K limit), keeps
 allocating a little bit, squeezing removes a little bit, and then it
 runs again.  So to avoid this, if we squeezed *and* there is still
 less than BLOCK_SIZE_W words free, then we enlarge the stack anyway.
] 
[add a comment to TSO_MARKED
Simon Marlow <marlowsd@gmail.com>**20091125104954
 Ignore-this: 7111281a443533dc453dbf9481dba519
] 
[Pass --no-user-package-conf to ghc-pkg in bindisttest
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091125115953] 
[Add a note saying what Haddock relies on about Instance.is_dfun
David Waern <david.waern@gmail.com>**20091124210308] 
[Treat () as an enumeration tycon
Ian Lynagh <igloo@earth.li>**20091124011313
 This fixes deriving Ord (), which previously failed with
   ghc-stage1: panic! (the 'impossible' happened)
     (GHC version 6.13.20091123 for x86_64-unknown-linux):
           TcGenDeriv:mk_FunBind
] 
[Whitespace only
Ian Lynagh <igloo@earth.li>**20091124003221] 
[inline has moved to GHC.Magic
Ian Lynagh <igloo@earth.li>**20091123200308] 
[Use the ghc-perl tarball on Windows, instead of the msys one
Ian Lynagh <igloo@earth.li>**20091120153953] 
[Install perl on Windows
Ian Lynagh <igloo@earth.li>**20091120223830] 
[Remove cprAnalysis directory from hs-source-dirs
simonpj@microsoft.com**20091120161911
 Ignore-this: e7d3707794979e45b43136137c939af1
] 
[Remove -fasm from mk/validate-settings.mk
Ian Lynagh <igloo@earth.li>**20091120125656
 Makes it easier to do unregisterised validate runs
] 
[Fix some dependencies in bindists
Ian Lynagh <igloo@earth.li>**20091120125342
 We can't depend on sources in a bindist, because we don't have the sources.
] 
[Add a rule to allow us to sdist libraries easily
Ian Lynagh <igloo@earth.li>**20091119160527] 
[Check upper/lower bounds on various RTS flags (#3633)
Simon Marlow <marlowsd@gmail.com>**20091119142422
 Ignore-this: 8cbbb3f0f2c46711967491d5c028a410
 
 Also, make K mean 1024 rather than 1000, in RTS flags (similarly for M
 and G).  The main reason I want to change it is that otherwise this
 might be confusing:
   
 exp3_8: error in RTS option -H4k: size outside allowed range (4096 - 18446744073709551615)
 
 And I think the original reason for using 1000 instead of 1024,
 worries about direct-mapped caches, is not an issue in this context
 (even if you can find a direct-mapped cache these days).
] 
[define HS_WORD_MAX
Simon Marlow <marlowsd@gmail.com>**20091119140143
 Ignore-this: ed27e7c7ac0bd03cddcd745ae7053a74
] 
[Print the prog name in errorBelch() even if prog_argv is not set yet
Simon Marlow <marlowsd@gmail.com>**20091119135230
 Ignore-this: ec42e7a4f344ebc34befddfc3d74a946
 This means we get the prog name in error messages from the flag parser
] 
[Remove dead code
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091112070455
 Ignore-this: d30b668cb3c396fe21e5e4cd9b8be151
] 
[Remove the (very) old strictness analyser
simonpj@microsoft.com**20091119154347
 Ignore-this: 5d49f66b0baad989ca66c53fde8f2d23
 
 I finally got tired of the #ifdef OLD_STRICTNESS stuff.  I had been
 keeping it around in the hope of doing old-to-new comparisions, but
 have failed to do so for many years, so I don't think it's going to
 happen.  This patch deletes the clutter.
] 
[Make INLINE warning more precise
simonpj@microsoft.com**20091119132711
 Ignore-this: f1494494f37c5e618e639912ff82a7f5
] 
[Implement -fexpose-all-unfoldings, and fix a non-termination bug
simonpj@microsoft.com**20091119125711
 Ignore-this: 54d029014659959151d1681842210cde
 
 The -fexpose-all-unfoldings flag arranges to put unfoldings for *everything*
 in the interface file.  Of course,  this makes the file a lot bigger, but
 it also makes it complete, and that's great for supercompilation; or indeed
 any whole-program work.
 
 Consequences:
   * Interface files need to record loop-breaker-hood.  (Previously,
     loop breakers were never exposed, so that info wasn't necessary.)
     Hence a small interface file format change. 
 
   * When inlining, must check loop-breaker-hood. (Previously, loop
     breakers didn't have an unfolding at all, so no need to check.)
 
   * Ditto in exprIsConApp_maybe.  Roman actually tripped this bug, 
     because a DFun, which had an unfolding, was also a loop breaker
 
   * TidyPgm.tidyIdInfo must be careful to preserve loop-breaker-hood
 
 So Id.idUnfolding checks for loop-breaker-hood and returns NoUnfolding
 if so. When you want the unfolding regardless of loop-breaker-hood, 
 use Id.realIdUnfolding.
 
 I have not documented the flag yet, because it's experimental.  Nor
 have I tested it thoroughly.  But with the flag off (the normal case)
 everything should work.
] 
[Re-implement the binder-swap stuff in OccurAnal
simonpj@microsoft.com**20091119124524
 Ignore-this: 662ed559e161be958b1eff1a49d750a3
 
 This is a pretty big patch, but it has a very local effect.
 It affects only the binder-swap mechanism in OccurAnal, which
 was not working well becuase it's more subtle than I'd realised
 (See Note [getProxies is subtle]).  I think this does a much
 better job.
] 
[Try harder not to make DFuns into loop breakers
simonpj@microsoft.com**20091119124127
 Ignore-this: 922d9a2b3406a3dbbfc5a42d1a286e2a
 
 See Note [DFuns should not be loop breakers]
] 
[Extend the GHCi FAQ slightly
simonpj@microsoft.com**20091117132308
 Ignore-this: 8257aaf06ff32904a91121a0734d1c4
] 
[Add gnutar to the list of names we use when looking for GNU tar
Ian Lynagh <igloo@earth.li>**20091119144927] 
[Add support for the man page to the new build system
Ian Lynagh <igloo@earth.li>**20091119140811] 
[Refactor case-merging and identical-alternative optimisations
simonpj@microsoft.com**20091119123704
 Ignore-this: db12d31395ed99c2341cc4d7d5dca1e
 
 These two optimisations were originally done by SimplUtils.mkCase
 *after* all the pieces have been simplified.  Some while ago I
 moved them *before*, so they were done by SimplUtils.prepareAlts.
 It think the reason was that I couldn't rely on the dead-binder 
 information on OutIds, and that info is useful in these optimisations.
 
 However, 
  (a) Other changes (notably moving case-binder-swap to OccurAnal)
      have meant that dead-binder information is accurate in 
      OutIds
 
  (b) When there is a cascade of case-merges, they happen in 
      one sweep if you do it after, but in many sweeps if you
      do it before.  Reason: doing it after means you are looking
      at nice simplified Core.
] 
[Fix a nasty infelicity in the size computation of CoreUnfold
simonpj@microsoft.com**20091119115736
 Ignore-this: ecff5289ab14c0df572135bf0b5179d6
 
 The size computation was treating gigantic case expressions as
 practically free, which they really aren't.  It was exacerbated by
 recent decisions to charge 0 for naked variables and constructors, so
 the RHS of the case might look free too.  A good example was 
 Foreign.C.Error.errnoToIOError, which hsa lots of join points
 that were getting inlined way to vigorously, so we had:
 
   *** Simplifier Phase 2 [main]:
       Result size = 2983
   *** Core Linted result of Simplifier mode 2 [main], iteration 1 out of 4:
       Result size = 640327
   *** Core Linted result of Simplifier mode 2 [main], iteration 2 out of 4:
       Result size = 1659
 
 Notice that gigantic intermediate!
 
 This patch adds a small charge for each *alternative*.  Of course,
 that'll also mean that there's a bit less inling of things involving
 case expressions.
] 
[Comments and white space only
simonpj@microsoft.com**20091119115122
 Ignore-this: dc8f9a72d6d57378d83154877b1d1126
] 
[Fix splitAppTys
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20091119102639
 Ignore-this: e669950c7d151c8a67910cd4bbac9cd6
] 
[Windows DLLs: Slurp across the actually static version of libffi
Ben.Lippmeier@anu.edu.au**20091119000239] 
[Windows DLLs: Don't rely on stg/DLL.h being included in RtsAPI.h
Ben.Lippmeier@anu.edu.au**20091118110548
 Ignore-this: 7dce0ede283974d7834fe12af3f71bd5
] 
[Fix warnings about unused imports
Ben.Lippmeier@anu.edu.au**20091118110525
 Ignore-this: 93841770eadabf5bd3b9f859ca2de7eb
] 
[Windows DLLs: stifle more warnings about auto imported symbols
Ben.Lippmeier@anu.edu.au**20091118090105] 
[Windows DLLs: stifle warnings about symbols being auto imported from DLLs
Ben.Lippmeier@anu.edu.au**20091118051526] 
[Windows DLLs: add #ifdefery to turn off DLL import of libffi when building statically.
Ben.Lippmeier@anu.edu.au**20091118043901] 
[Windows DLLs: disable extra shutdownHaskell() when unloading the RTS DLL
Ben.Lippmeier@anu.edu.au**20091117050648] 
[Windows DLLs: remove dup symbol from def file
Ben.Lippmeier@anu.edu.au**20091117043851] 
[Use opt_PIC not #defined __PIC__ in compiler source.
Ben.Lippmeier@anu.edu.au**20091117043716] 
[Windows DLLs: CHARLIKE_closure and INTLIKE_closure aren't defined in this way.
Ben.Lippmeier@anu.edu.au**20091114063240] 
[If a comment says "Is this correct?", it's not.
Ben.Lippmeier@anu.edu.au**20091114063157] 
[Windows DLLs: gmp is in the integer-gmp package now.
Ben.Lippmeier@anu.edu.au**20091114063046] 
[Use DLL aware runIO_closure instead of base_GHCziTopHandler_runIO_closure directly
Ben.Lippmeier@anu.edu.au**20091114061559] 
[RTS also uses runSparks_closure from base
Ben.Lippmeier@anu.edu.au**20091114061445] 
[Provide extralibs when linking Windows DLLs
Ben.Lippmeier@anu.edu.au**20091114061109] 
[Don't share low valued Int and Char closures with Windows DLLs
Ben.Lippmeier@anu.edu.au**20091114060455] 
[Windows DLLs: use one import lib for each DLL the RTS needs.
Ben.Lippmeier@anu.edu.au**20091111014821] 
[Add autoconf code to locate dlltool on Windows
Ben.Lippmeier@anu.edu.au**20091110051257] 
[Break recursive imports between the RTS and base library on Windows.
Ben.Lippmeier@anu.edu.au**20091106062732
 
 The file rts/win32/libHSbase.def contains a list of all the 
 symbols from the base library that the RTS needs. 
 
 When building the RTS into a DLL on Windows, we want to link the DLL
 for the RTS before we link the DLL for the base library. We use 
 libHSbase.def to make the "import library" libHSbase.so.a, which 
 contains stubs for each of the symbols from the base library that
 the RTS needs.
] 
[Add the msysCORE*.tar.gz tarball to the list of tarballs we unpack
Ian Lynagh <igloo@earth.li>**20091118195523] 
[Put the libffi files to be installed into a dist directory
Ian Lynagh <igloo@earth.li>**20091118150508
 This meakes it easier to correctly clean libffi
] 
[Add ghc-tarballs to the list of directories that go into an sdist
Ian Lynagh <igloo@earth.li>**20091118131047] 
[Remove redundant libffi/tarball directory
Ian Lynagh <igloo@earth.li>**20091118124102
 We now use the tarball in the ghc-tarballs repo
] 
[Fix gen_contents_index on MSYS
Ian Lynagh <igloo@earth.li>**20091117223556
 On MSYS
     sed 's/.*[ \t]//'
 wasn't matching
     version:<tab>1.0
 so I've switched to
     's/.*[[:space:]]//'
 which works on Linux, cygwin and MSYS.
] 
[include the GHC package docs in a bindist
Simon Marlow <marlowsd@gmail.com>**20091117151133
 Ignore-this: c4a10221b1a2a4778494018bca7d2169
] 
[exclude some haddock-related rules during BINDIST
Simon Marlow <marlowsd@gmail.com>**20091117151123
 Ignore-this: 20b4194b26766d6ab701683af520a7d4
] 
[Add an install-docs target that emits a helpful diagnostic (#3662)
Simon Marlow <marlowsd@gmail.com>**20091116120137
 Ignore-this: 1c5414730614b205c67919f3ea363c00
] 
[fix install_docs dependencies, and add a missing $(INSTALL_DIR)
Simon Marlow <marlowsd@gmail.com>**20091116115630
 Ignore-this: 21230df54e79f12f61e9c82a0ae02fad
] 
[Tweak to the directory-building rule
Simon Marlow <marlowsd@gmail.com>**20091113125719
 Ignore-this: b9e1fe6bcbfd4ff56905517f32b646f7
 So we don't try to recreate directories just because they are older
 than mkdirhier, since mkdirhier won't touch them.
] 
[exprIsHNF should "look through" lets
simonpj@microsoft.com**20091117125526
 Ignore-this: 3e77d029c0f314c53171f0378939b496
 
 I can't quite remember when I spotted this, but exprIsHNF (and
 similarly exprIsConLike) should ignore enclosing let-bindings,
 since they don't affect termination.
] 
[Improvement to typecheck higher-rank rules better
simonpj@microsoft.com**20091117125417
 Ignore-this: c5791cbe9540376b9ff46e2a6563bcc2
 
 See Note [Typechecking rules] in TcRules.  
 Suggested by Roman
] 
[Apply RULES to simplified arguments
simonpj@microsoft.com**20091117104437
 Ignore-this: 9a3475a9871f45ffa115dec44e376e3c
 
 See Note [RULEs apply to simplified arguments] in Simplify.lhs
 A knock-on effect is that rules apply *after* we try inlining
 (which uses un-simplified arguments), but that seems fine.
] 
[Improvements to pretty-printing of Core
simonpj@microsoft.com**20091117103626
 Ignore-this: ad386865644b4dbcd98adab409d7c523
] 
[Fix formatting of module deprecation/warning messages
Duncan Coutts <duncan@well-typed.com>**20091115155617
 Ignore-this: a41444bdda003aee4412eb56a0e7d052
 It was accidentally using list syntax. Fixes #3303 again.
] 
[Wibble to comment
simonpj@microsoft.com**20091113145944
 Ignore-this: 730f7cad452ac96d59ee2e74a855c19d
] 
[TAG 2009-11-15
Ian Lynagh <igloo@earth.li>**20091115155059] 
Patch bundle hash:
f9fc7807724a2421babc207e46157012c199343e
